# MySQL 优化原理二

标签（空格分隔）： DB

---

- **[参考原文](https://www.jianshu.com/p/01b9f028d9c7)**

## 数据界限
- MySQL4.x，MyISAM 存储引擎 500W 行
- MySQL5.x，性能拐点则为 1KW ~ 2KW 行级别

## 分表
- 从业务角度处理
- 水平拆分（如：按月拆分到不同表）
- 垂直拆分（如：不同状态的订单拆分到不同的表）


## 分区
- MySQL 底层实现分表
- 分区表是一个独立的逻辑表，底层由多个物理子表组成
- 所有底层表必须使用相同的存储引擎
- 分区表的索引也是在各个底层表上各自加上一个完全相同的索引

### 分区用法
- 选择一些更粗粒度并且消耗更少的方式来检索数据
- 如先根据索引找到一大块数据，然后再在这块数据上顺序扫描

### 分区表锁
- CURD，分区层先打开并锁住所有的底层表
- 并不是说分区表在处理过程中是锁住全表的
- 如果存储引擎能够自己实现行级锁，例如InnoDB，则会在分区层释放对应表锁
- 这个加锁和解锁的操作过程与普通InnoDB上的查询类似

### 保证大数据量的可扩展性
- 全量扫描数据，不用索引。
  - 即只要能够根据WHERE条件将需要查询的数据限制在少数分区中，效率是不错的
- 索引数据，分离热点。
  - 如果数据有明显的“热点”，而且除了这部分数据，其他数据很少被访问到，
  - 那么可以将这部分热点数据单独存放在一个分区中

### WHERE 条件中带入分区列
- 可以让优化器能够过滤掉无须访问的分区
- 查询都能够过滤掉很多额外的分区、分区本身并不会带来很多额外的代价

### NULL 的影响
- NULL 或非法值时，记录都会被存放到第一个分区
  - 如：YEAR() 在接收非法值时会返回 NULL
- `WHERE order_date BETWEEN '2017-05-01' AND '2017-05-31'`，会检查两个分区
- 解决：创建一个无用的分区，如：`PARTITION p_null values less than (0)`
- MySQL5.5 以后不需要这个技巧

### 分区的成本可能很高
- 对于大多数系统，100个左右的分区是没有问题的。

### 打开并锁住所有底层表的成本在某些时候会很高
- 如只需要查询主键，那么锁住的成本相对于主键的查询来说，成本就略高。

### 维护分区的成本可能会很高
- 新增和删除分区的速度都很快，但是修改分区会造成数据的复制，
- 这与 `ALTER TABLE` 的原理类似，需要先创建一个历史分区，
- 然后将数据复制到其中，最后删除原分区
- MySQL5.6 以后，性能有很大提升

### 分区-资源限制
- 分区一般应用于一台服务器上，但一台服务器的物理资源总是有限的，
- 当数据达到这个极限时，即使分区，性能也可能会很低，所以这个时候分库是必须的。


## 视图
### 查看用哪种算法
- `EXPLAN EXTENDED` 之后，再 `SHOW WARNINGS`（或同时执行）
- 临时表算法：EXPLAIN 中会显示为派生表（DERIVED）

### 临时表算法
- 没有任何索引，优化器很难优化临时表上的查询，
- 因此，如有可能，尽量使用合并算法会有更好的性能

### 为何使用视图
- 更多的是基于业务或者维护成本上的考虑
- 其本身并不会对性能提升有多大作用
  - 注意：此处只是基于MySQL考虑，其他关系性数据库中视图可能会有更好的性能，
  - 比如 ORACLE 和 SQL SERVER 都支持物化视图，它们都比MySQL视图有更好的性能

### 使用算法时机
- 原表记录和视图中的记录无法建立一一映射的关系时，MySQL都将使用临时表算法来实现视图
  - 如创建视图的SQL中包含GROUP BY、DISTINCT、UNION、聚合函数、子查询时

### 物化视图
- 将视图结果数据存放在一个可以查询的表中，并定期从原始表中刷新数据到这张表中，
- 这张表和普通物理表一样，可以创建索引、主键约束等等，性能相比于临时表会有质的提升


## 存储过程与触发器

### 存储过程-优点
- 可以非常方便的加密存储过程代码，而不用担心应用部署到私有环境造成源代码泄露、
- 可以像调试其他应用程序一样调试存储过程、
- 可以设定存储过程的使用权限来保证数据安全

### 触发器-优点
- 一般用于实现一些强制的限制，
- 这些限制如果在应用程序中实现会让业务代码变得非常复杂，
  - 而且它也可以减少客户端与服务器之间的通信

### 触发器-原理 
- 对一张表的每一个事件，最多只能定义一个触发器
- 只支持“基于行的触发”，也就是触发器始终是针对一条记录的，而不是针对整个SQL语句。
- 如果是批量更新的话，效率可能会很低

### 触发器-原子性探讨
- 触发器并不一定能保证原子性，
- 比如MyISAM引擎下触发器执行失败了，也不能回滚。
- 在InnoDB表上的触发器是在同一个事务中执行完成的，是原子的，
  - 原操作和触发器操作会同时失败或者成功。
  
----
---
## 索引选择性
- 是指不重复的索引值和数据表的总记录数的比值，
- 选择性越高查询效率越高，
- 因为选择性越高的索引可以让 MySQL 在查询时过滤掉更多的行。
- 唯一索引的选择性是 1，这是最好的索引选择性，性能也是最好的。


## 外键约束
- 大数据场景下，不建议使用外键

### 外键-成本1
- 外键通常要求每次修改数据时都要在另外一张表中执行一次查找操作
- InnoDB 存储引擎会强制外键使用索引
- 当外键的选择性很低时，会导致一个非常大且选择性低的索引。

### 外键-成本2
- 如果向子表中插入一条记录，
- 外键约束会让InnoDB检查对应的父表的记录，
- 也就需要对父表对应记录进行加锁操作，
- 来确保这条记录不会在这个事务完成之时就被删除了。
- 这会导致额外的锁等待，甚至会导致一些死锁。

### 外键-优点
- 不考虑性能问题
- 外键要比在应用程序中检查一致性方便简单许多
- 数据的删除和更新操作比在应用中要高效


## 绑定变量
- 如：` order_status = ? and buyer = ?`
- 预先编译，减少 SQL 注入风险

### 绑定变量-优点
- 解析并存储 SQL 语句的部分执行计划，返回给客户端一个 SQL 语句处理句柄
- 客户端通过向服务器发送各个问号的取值和这个句柄来执行具体查询
  - 服务器只需要解析一次SQL语句
  - 服务器某些优化工作也只需要做一次，因为 MySQL 会缓存部分执行计划
  - 通信中仅仅发送的是参数，而不是整个语句，网络开销也会更小

### 绑定变量-注意
- 某些不支持预编译的JDBC驱动，
- 在调用connection.prepareStatement(sql)时，
- 并不会把SQL语句发送给数据库做预处理，
- 而是等到调用executeQuery方法时才把整个语句发送到服务器


## 用户自定义函数
- (user-defined function)，也称为：UDF
- 存储过程只能使用SQL来编写
- UDF 没限制，可以使用支持 C 语言调用约定的任何编程语言来实现
- `CREATE FUNCTION json_values RETURNS STRING SONAME 'lib_mysqludf_json.so';`
- 大致流程：使用 C 语言实现逻辑 -> 编译成 .so 文件 -> 创建函数 -> 使用函数。


## 字符集
- 是指一种从二进制编码到某类字符符号的映射

### MySQL 字符集
- 逐层继承
- 创建数据库时，根据服务器上的character_set_server来设置数据库的默认字符集，
- 根据database的字符集来指定库中所有表的字符集
- 不管是对数据库，还是表和列，只有当它们没有显式指定字符集时，默认字符集才会起作用。

### 字符集-校对规则
- 大小写敏感的方式比较字符串 或者 字符串编码的二进制来比较大小，
  - 其对应的校对规则的后缀分别是 `_cs`（现无）、`_ci` 和 `_bin`
- 示例
  - `utf8_bin` 将字符串中的每一个字符用二进制数据存储，区分大小写
  - `utf8_general_ci` 不区分大小写，ci 为 case insensitive 的缩写，即大小写不敏感
  - `utf8_general_cs` 区分大小写，cs 为 case sensitive 的缩写，即大小写敏感
  
### 排序影响
- 默认不转换时，可以用到索引排序
- `ORDER BY name COLLATE utf8_bin desc`
  - 会尝试转换其中一个列的字符集。
  - 这和在数据列外面封装一个函数一样，无法使用这个列上的索引。
  - `EXPLAIN` 查看时，有 `Using filesort` 提示