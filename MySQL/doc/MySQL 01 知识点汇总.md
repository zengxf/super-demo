
---
#### 事务的并发问题
- https://blog.csdn.net/weixin_42047611/article/details/81772149
1. **脏读**：
	- 事务 A 读取了事务 B **更新**的数据
	- 然后 B **回滚**操作
	- 那么 A 读取到的数据就是**脏数据**
2. **不可重复读**：
	- 事务 A 多次读取同一事物
	- 事务 B 在事务 A 多次读取的过程中
	- 对数据做了**更新并提交**
	- 导致事务 A 多次读取同一数据时，结果不一致
3. **幻读**：
	- 系统管理员 A 将数据库中的所有学生的成绩从具体分数改为`1234`等级
	- 但是系统管理员 B 就在这个时候**插入**了一条具体分数的记录
	- 当系统管理员 A 改结束后发现还有一条记录没有改过来
	- 就好像**发生了幻觉一样**，这就叫**幻读**
- 小结：**不可重复读**和**幻读**很容易混淆
  - **不可重复读**侧重于**修改**
  - **幻读**侧重于**新增或删除**
  - 解决**不可重复读**的问题只需**锁住满足条件的行**
  - 解决**幻读**需要**锁表**

---
#### InnoDB 引擎的 4 大特性
- **插入缓冲**
  - 对于非聚集类索引的插入和更新操作
  - 不是每一次都直接插入到索引页中，而是先插入到内存中
  - 再以一定的频率和索引页合并
  - 要求：索引是辅助索引，不适合唯一性
- **二次写**
  - 数据库 IO 的最小单位是 `16K`
  - 文件系统 IO 的最小单位是 `4K`
  - 磁盘 IO 的最小单位是 `0.5K(512B)`
  - 提高 InnoDB 的可靠性，用来解决部分写失败
  - **重做日志**（`redo log`）记录的是对页的物理修改
    - 如果页本身已经损坏，**重做日志**也无能为力
  - 原理：先拷贝至内存中写缓冲区
    - 接着从写缓冲区写入磁盘共享表空间中
    - 再将写缓冲区写入数据文件
- **自适应哈希索引**
  - 原理：监控对表上二级索引的查找，如果发现某二级索引被频繁访问
    - 二级索引成为热数据，建立哈希索引可以带来速度的提升
  - 经常访问的二级索引数据会被自动生成到 Hash 索引里面去（最近连续被访问 `3` 次的数据）
- **预读**
  - 用于 I/O 优化
  - 预读请求是一个 I/O 请求，它会异步地在缓冲池中预先回迁多个页面
  - 预计很快就会需要这些页面

---
#### 最左前缀原则
- 也就是最左优先，这条原则针对的是组合索引和前缀索引，理解：
- 1、在 MySQL 中，进行条件过滤时
  - 是按照向右匹配直到遇到范围查询（>,<,between,like）就停止匹配
  - 比如说 `a = 1 and b = 2 and c > 3 and d = 4` 如果建立 `(a,b,c,d)` 顺序的索引
  - d 是用不到索引的，如果建立 `(a,b,d,c)` 索引就都会用上
  - 其中 a，b，d 的顺序可以任意调整
- 2、= 和 in 可以乱序，比如 `a = 1 and b = 2 and c = 3` 建立 `(a,b,c)` 索引
  - 可以任意顺序，MySQL 的查询优化器会优化索引可以识别的形式

#### 两阶段锁
- 传统的 RDBMS 加锁的一个原则
- 就是 2PL(Two-Phase Locking，二阶段锁)
- 也就是说锁操作分为两个阶段：加锁阶段和解锁阶段
  - 并且保证加锁阶段和解锁阶段不相交
- 也就是说在一个事务中，不管有多少条增删改
  - 都是在加锁阶段加锁
  - 在 commit 后，进入解锁阶段，才会全部解锁

#### 多版本并发控制
- 在 MySQL 默认存储引擎 InnoDB 中
  - 实现的是基于多版本的并发控制协议——MVCC（Multi-Version Concurrency Control）
  -（注：与 MVCC 相对的，是基于锁的并发控制，Lock-Based Concurrency Control）
- 其中 MVCC 最大的好处是：读不加锁，读写不冲突
- 在读多写少的 OLTP 应用中，读写不冲突是非常重要的，极大的提高了系统的并发性能
- 一句话总结：同一份数据临时保存多个版本的一种方式，进而实现并发控制

#### 当前读和快照读
- 在 MVCC 并发控制中，读操作可以分为两类：快照读与当前读
- 快照读（简单的 select 操作）
  - 读取的是记录中的可见版本（可能是历史版本），不用加锁
- 当前读（特殊的 select 操作、insert、delete 和 update）
  - 读取的是记录中最新版本，并且当前读返回的记录都会加上锁
  - 这样保证了其他事务不会再并发修改这条记录

#### 聚集索引
- 也叫做聚簇索引
- 在 InnoDB 中，数据的组织方式就是聚簇索引：
  - 完整的记录，储存在主键索引中
  - 通过主键索引，就可以获取记录中所有的列

#### Gap 锁和 Next-Key 锁
- 在 InnoDB 中完整行锁包含三部分：
- 记录锁（Record Lock）：锁定索引中的一条记录
- 间隙锁（Gap Lock）：
  - 要么锁住索引记录中间的值
  - 要么锁住第一个索引记录前面的值或最后一个索引记录后面的值
- Next-Key Lock：是索引记录上的记录锁和在记录之前的间隙锁的组合

#### MySQL 隔离级别
- MySQL/InnoDB 中，定义了四种隔离级别：
- `Read Uncommitted`：可以读取未提交记录。此隔离级别不会使用
- `Read Committed`（RC）：针对当前读
  - RC 隔离级别保证了对读取到的记录加锁（记录锁），存在幻读现象
- `Repeatable Read`（RR）：针对当前读
  - RR 隔离级别保证对读取到的记录加锁（记录锁）
  - 同时保证对读取的范围加锁
  - 新的满足查询条件的记录不能够插入（间隙锁），不存在幻读现象
- `Serializable`：从 MVCC 并发控制退化为基于锁的并发控制
  - 不区别快照读和当前读，所有的读操作都是当前读，读加读锁（S 锁），写加写锁（X 锁）
  - 在该隔离级别下，读写冲突，因此并发性能急剧下降，在 MySQL/InnoDB 中不建议使用