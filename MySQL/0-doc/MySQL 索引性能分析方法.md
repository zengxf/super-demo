# MySQL 索引性能分析方法

标签（空格分隔）： DB

---

**[原文参考](https://draveness.me/sql-index-performance)**

## 分析索引性能的方法
- 快速分析、估算索引的性能，及时发现问题
- 基本问题法（BQ: Basic Question）
- 快速估算上限法（QUBE: Quick Upper-Bound Estimate）

## 基本问题法
- 现有的索引或者即将添加的索引是否包含了 WHERE 中使用的全部列，也就是对于当前查询来说，是否有一个索引是半宽索引。

## 快速估算上限法
- 一种更加准确、复杂的方法
- 估算方法的输出就是本地响应时间（Local Response Time）

### 本地响应时间
- 就是查询在数据库服务器中的耗时
- - 不包括任何的网络延迟和多层环境的通信时间，仅包括执行查询任务的耗时
- 本地响应时间等于**服务时间**和**排队时间**的总和
- - 主要部分还是**磁盘的服务时间**
- QUBE 在计算的过程中会忽略除了**磁盘排队时间**的其他排队时间
- 主要还是包括**同步读写**以及**异步读**几个部分
- LRT = #Random * 10ms + #Sequential * 0.01ms + #Fetch * 0.1ms
- - 其中数据获取的过程在比较不同的索引对同一查询的影响是不需要考虑的
```
当使用全表扫描或者扫描索引片时，读取的第一个行就是随机访问
顺序读取的**索引行**都是通过顺序访问读取的，代价只有随机访问的千分之一
零星的随机访问，仍然把它们当做顺序访问进行估算
```
- 索引中的列并不能满足查询的需要时，对于每一个索引行都会产生一次表的随机访问，以获取**剩余列**
```
两个查询条件分别有着 0.05% 和 12% 的过滤因子
查询总共会访问 10,000,000 * 0.05% * 12% = 600 条数据
Index Scan: 1 次的随机访问和 599 次的顺序访问
Table Scan: 获取剩余列：600 次随机访问
Fetch: 取回结果集的过程中也会有 600 次 FETCH 操作
总体看：601 次随机访问、599 次顺序访问和 600 次 FETCH
    = 6010 + 5.99 + 60 = 6075.99ms
```