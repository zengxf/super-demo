# MySQL 优化原理一

标签（空格分隔）： DB

---

- **[原文参考](https://www.jianshu.com/p/d7665192aaaf)**

## 架构整体分为三层
- 最上层为**客户端层**
  - 连接处理、授权认证、安全
- 中间一层为**核心服务**
  - 查询解析、分析、优化、缓存、内置函数
  - 存储过程、触发器、视图
- 最下层为**存储引擎**
  - 数据存储和提取
  - 和 Linux 的文件系统类似
- 中间服务层通过API与存储引擎通信，
  - 这些API屏蔽不同存储引擎间的差异。

---
## MySQL 查询过程

### 客户端/服务端通信协议
- 半双工：在任一时刻，要么是服务器向客户端发送数据，要么是客户端向服务器发送数据，不能同时发生。
  - 一端开始发送消息，另一端要接收完整个消息才能响应它，
  - 所以无须将消息切成小块独立发送，也不能进行流量控制。
- 客户端查询太大，服务端会拒绝接收。
- 服务器响应客户端请求时，客户端必须完整的接收整个返回结果，而不能只取前面几条。

### 查询缓存
- 缓存存放在一个映射表
  - 通过哈希值索引，查询本身、要查询的数据库、客户端协议版本号等信息计算得来
  - 所以两个查询在任何字符上的不同（例如：空格、注释），都会导致缓存不会命中
- 查询中包含任何用户自定义函数、存储函数、用户变量、临时表、mysql 库中的系统表，
  - 其查询结果都不会被缓存。
  - 如函数`NOW()`或者`CURRENT_DATE()`
  - 再比如`CURRENT_USER`或者`CONNECION_ID()`

#### 缓存失效
- 查询中涉及的每个表，发生变化，那么和这张表相关的所有缓存数据都将失效。
  - 如任何写操作
- 如果查询缓存非常大或者碎片很多，可能带来很大的系统消耗
  - 读操作同样：之前检查，命中缓存；执行后，存入缓存
- 数据库设计优化
  - 用多个小表代替一个大表，注意不要过度设计
  - 批量插入代替循环单条插入
  - 合理控制缓存空间大小，一般几十兆比较合适
  - 通过`SQL_CACHE`和`SQL_NO_CACHE`控制查询是否进行缓存
- 不要轻易打开查询缓存，如：写密集型应用
- 如需要：将`query_cache_type`设置为`DEMAND`，只有`SQL_CACHE`的查询才会走缓存

### 语法解析和预处理
- 通过关键字将SQL语句进行解析，并生成解析树
  - 通过语法规则来验证和解析
  - 是否使用了错误的关键字或者关键字的顺序是否正确
- 预处理：根据MySQL规则进一步检查解析树是否合法。如检查要查询的数据表和数据列是否存在

### 查询优化
- 优化器将语法树转化成查询计划。
- 多数情况下，一条查询可以有很多种执行方式，最后都返回相应的结果。
- 优化器的作用就是找到这其中最好的执行计划。

#### 查询成本
- MySQL使用基于成本的优化器，
- 尝试预测一个查询使用某种执行计划时的成本，并选择其中成本最小的一个。
- 可以通过查询当前会话的`last_query_cost`的值来得到其计算当前查询的成本。
- `show status like 'last_query_cost'`，值为需要做 N 个数据页的随机查找。

#### 错误执行计划的原因
- 统计信息不准确、不会考虑不受其控制的操作成本（用户自定义函数、存储过程）、
- MySQL选择它认为成本小的，但成本小并不意味着执行时间短

---
#### 查询优化方式
- 重新定义表的关联顺序
- 根据索引优化`MIN()`和`MAX()`函数
- 提前终止查询（如：`Limit`）
- 优化排序（读取所有的数据行，根据给定的列排序）

### 查询执行引擎
- 完成解析和优化后，生成对应的执行计划，查询执行引擎根据执行计划给出的指令逐步执行得出结果。
- 通过调用存储引擎实现的接口完成，这些接口被称为handler API。
- 查询过程中的每一张表由一个handler实例表示。
- 在优化阶段创建handler实例。
  - 获取表的相关信息，包括列名、索引统计信息等。

### 返回结果给客户端
- 如果查询缓存打开且可被缓存，将结果存放到缓存中。
- 结果集返回是一个增量且逐步返回的过程。
  - 有可能在生成第一条结果时，就开始返回了。
  - 服务端无须存储太多结果而消耗过多内存，客户端也第一时间获得返回结果。

### 整个查询分为 6 步
- 客户端发送查询请求
- 服务器首先检查查询缓存，如果命中，则立刻返回缓存中的结果
  - 否则进入下一阶段
- 服务器进行SQL解析、预处理
- 再由优化器生成对应的执行计划
- MySQL根据执行计划，调用存储引擎的API来执行查询
- 将结果返回，同时缓存结果

---
## 性能优化建议
- 不要听信关于优化的“绝对真理”，而应该实际通过测试验证执行计划以及响应时间。

### 表设计与数据类型优化
- 数据类型遵循小而简单的原则就好，越小的数据类型通常会更快，占用更少的磁盘、内存，处理时CPU周期更少。

#### 几个注意的技巧
- NULL 改为 NOT NULL 不会性能提升；如果创建索引，应该将列设置为 NOT NULL。
- 整数类型指定宽度，如INT(11)，没有任何卵用（4 字节存储）。
- UNSIGNED 不允许负值，使正数的上限提高一倍。
- 存储财务数据时，可以使用 BIGINT。避免浮点数计算不准确和 DECIMAL 精确计算代价高的问题。
- TIMESTAMP 使用 4个 字节存储空间，DATETIME 使用 8个 字节存储空间。
  - TIMESTAMP 只能表示 1970 - 2038年，比 DATETIME 表示的范围小，且因时区不同而不同。
- 列不要太多。存储引擎的API工作时需要行缓冲格式拷贝数据，然后在服务器层将缓冲内容解码成各个列，转换过程代价非常高。
  - 如果列太多而实际使用的列又很少，会导致CPU占用过高。
- 大表 ALTER TABLE 非常耗时，大部分修改表操作是用新的结构创建一个张空表，
  - 从旧表中查出所有的数据插入新表，然后再删除旧表。
  - 当内存不足而表又很大，而且还有很大索引的情况下，耗时更久。

---
## 创建高性能索引

### 索引数据结构和算法
- 平衡二叉树，称为AVL树
- B+Tree 中的 B 是指 balance，意为平衡
- B+树 索引并不能找到一个给定键值的具体行，它只是找到数据行所在的页，然后把页读入到内存，再在内存中进行查找

#### m叉树
- 多路搜索树
- 减少树的深度
- B+Tree 是其中一种

#### B+Tree
- 所有的关键字（可以理解为数据）都存储在叶子节点（Leaf Page）
- 非叶子节点（Index Page）并不存储真正的数据
- 所有的叶子节点由指针连接
- 假设 B+Tree 的高度为 h，一次检索最多需要 h-1 次 I/O（根节点常驻内存）
- 树的高度一般比较小，通常不超过 3，`h = logmN`, M 通常较大，常常超过 100
- 维护索引要花费很大的代价，合理的创建索引尤为重要

### 索引“最左原则”
- `key(last_name, first_name, dob)`
- 索引首先根据第一个字段 `last_name` 排序
- 第一个相同时，再根据第二个字段 `first_name` 排序
- 第二个也相同时，再根据第三个字段 `dob` 排序
- 因此选择性更高的字段放到索引的前面

### 不用索引的情况：非独立的列
- “独立的列”是指索引列不能是表达式的一部分，也不能是函数的参数
- `where id + 1 = 5` 无法自动解析这个表达式

### 前缀索引
- 如果列很长，可以索引开始的部分字符，有效节约索引空间，提高索引效率

### 多列索引和索引顺序
- 在多个列上建立独立的索引并不能提高查询性能
- 因为 MySQL 不知道哪个索引的查询效率更好
- 5.0 之后的新版本会采用合并索引的策略
  - 将 `or` 变成 `union all`
- 当多个索引做 AND 查询时，一个包含所有相关列的索引要优于多个独立索引
- 当多个索引做 OR 查询时，对结果集的合并、排序等操作需要耗费大量的CPU和内存资源
  - 特别是某些索引的选择性不高，大量数据时，查询成本更高
  - 所以不如全表扫描
- 执行计划 Extra 字段出现 `Using union` 时，要注意

### 避免多个范围条件
- 如：`where login_time > '2017-04-01' and age between 18 and 30`
- MySQL 可以使用 login_time 列的索引或者 age 列的索引，但无法同时使用它们

### 覆盖索引
- 包含或者说覆盖所有需要查询的字段的值，不需要回表查询

### 使用索引扫描来排序
- explain 结果中 type 列的值为 index 表示使用了索引扫描来做排序
- 扫描索引本身很快，只需从一条索引记录移动到相邻的下一条记录
- 如果索引不能覆盖所有查询的列，每扫描一条索引记录就回表查询一次对应的行
- 基本是随机I/O，按照索引顺序读取数据的速度通常要比顺序地全表扫描要慢

### 冗余和重复索引
- 冗余索引是指在相同的列上按照相同的顺序创建相同类型的索引
- 应尽量避免，发现后立即删除
- 如有一个索引(A,B)，再创建索引(A)就是冗余索引
- 尽量扩展已有索引而不是创建新索引

### 删除长期未使用的索引
- 对于非常小的表，全表扫描更高效
- 对于中到大型的表，索引非常有效
- 对于超大型的表，建立和维护索引的代价随之增长，其他技术更有效，如分区表

---
## 特定类型查询优化

### COUNT() 查询
- 统计列值时，要求列值是非空的，不会统计 NULL
- `COUNT(*)` ，并不是扩展成所有的列，它会忽略所有的列而直接统计行数

### 优化关联查询
- 确保 ON 和 USING 字句中的列上有索引
- 当表A和表B用列c关联的时候，如果优化器关联的顺序是A、B，那么不需要在A表的列上创建索引
- 没有用到的索引会带来额外的负担，只需要在第二张表的列上创建索引

#### MySQL 关联执行策略
- 对任何的关联都执行嵌套循环关联操作
- 即先在一个表中循环取出单条数据
- 然后在嵌套循环到下一个表中寻找匹配的行

#### 示例
- `FROM A INNER JOIN B USING(c)`
- 伪代码：`for A: { for B(and c=A.c): { while(hasNext) { addToA(); } } }`
- 最外层的查询 A.c 索引不会使用

### 优化 LIMIT 分页
- 排序时，如果有对应的索引，通常效率会不错，否则，MySQL 需要做大量的文件排序操作
- 尽可能的使用覆盖索引扫描
- 根据需要做一次关联查询再返回所有的列
- 或者关联一个冗余表，冗余表只包含主键列和需要做排序的列

### UNION 原理及优化
- 处理策略是先创建临时表，然后再把各个查询结果插入到临时表中
- 需要手动将 WHERE、LIMIT、ORDER BY 等字句“下推”到各个子查询中
- 没有 ALL 关键字，MySQL 会给临时表加上 DISTINCT 选项，导致整个临时表的数据做唯一性检查，代价非常高

---
## 思考

### 存储过程
- 既然客户端都能干这些事，那为什么还要存储过程？

### 视图
- 安全：保密字段
- 性能：避免使用 JOIN 查询数据
- 灵活：旧表被废弃，直接映射到新表
- 合并算法：指查询视图时将视图定义的 sql 合并到查询 sql 中
- 临时表算法：将视图查出来的数据保存到临时表中，查询时查这个临时表




