#### MySQL 8.0 窗口函数
- https://dbaplus.cn/news-11-2258-1.html
- MySQL 从 8.0 开始支持**窗口函数**
  - 这个功能在大多商业数据库和部分开源数据库中早已支持
  - 有的也叫**分析函数**
- 什么叫窗口？
  - 窗口的概念非常重要，它**可以理解为记录集合**
    - **窗口函数也就是在满足某种条件的记录集合上执行的特殊函数**
  - 对于每条记录都要在此窗口内执行函数
    - 有的函数随着记录不同，窗口**大小都是固定的**，这种**属于静态窗口**
    - 有的函数则相反，**不同的记录对应着不同的窗口**，这种动态变化的窗口**叫滑动窗口**
- **窗口函数和普通聚合函数**也很容易混淆，二者**区别如下**
  - **聚合函数是将多条记录聚合为一条**
    - **而窗口函数是每条记录都会执行，有几条记录执行完还是几条**
  - 聚合函数也可以用于窗口函数中
- 窗口函数的基本用法如下：
  - `函数名([expr]) over (子句)`
  - 其中，`over` 是关键字，用来指定函数执行的窗口范围
  - 如果后面括号中什么都不写
    - 则意味着窗口包含满足 `where` 条件的所有行
    - 窗口函数基于所有行进行计算；
  - 如果不为空，则支持以下四种语法来设置窗口：
- `window_name`：
  - 给窗口指定一个别名
  - 如果 SQL 中涉及的窗口较多
    - 采用别名可以看起来更清晰易读
  - 下面例子中指定一个别名 `w`，则改写如下：
```sql
SELECT * FROM (
  SELECT row_number() OVER w AS row_num,
    order_id, user_no, amount, create_date
  FROM order_tab
  WINDOW w AS (partition by user_no order by amount desc)
) t;
```
- `partition` 子句：
  - 窗口按照那些字段进行分组
  - 窗口函数在不同的分组上分别执行
  - 上面的例子就按照用户 `id` 进行了分组
  - 在每个用户 `id` 上
  - 按照`order by`的顺序分别生成从 `1` 开始的顺序编号
  - **支持多个字段**
- `order by` 子句：
  - 按照哪些字段进行排序，窗口函数将按照排序后的记录顺序进行编号
  - 可以和 `partition` 子句配合使用，也可以单独使用
  - 上例中二者同时使用，如果没有 `partition` 子句
  - 则会按照所有用户的订单金额排序来生成序号
- `frame` 子句：
  - `frame` 是当前分区的一个子集
    - 子句用来定义子集的规则
    - 通常用来**作为滑动窗口使用**
  - 比如要根据每个订单动态计算包括本订单和按时间顺序前后两个订单的平均订单金额
    - 则可以设置如下 `frame` 子句来创建滑动窗口

#### MySQL 支持的非聚合窗口函数
- 归类参考： https://dbaplus.cn/news-11-2258-1.html
- 按照功能划分，可以把 MySQL 支持的窗口函数分为如下几类：
  - **序号函数**：`row_number() / rank() / dense_rank()`
  - **分布函数**：`percent_rank() / cume_dist()`
  - **前后函数**：`lag() / lead()`
  - **头尾函数**：`first_value() / last_value()`
  - **其他函数**：`nth_value() / ntile()`

- 表参考： https://www.modb.pro/db/61070

名称 | 描述
-- | --
`row_number()` | 分区内当前行的行号
`rank()` | 当前行在其分区中的排名，稀疏排序
`dense_rank()` | 当前行在其分区中的排名，稠密排序
-- | -x
`percent_rank()` | 排名值的百分比
`cume_dist()` | 累积分配值
-- | -x
`lag()` | 取排在当前行**之前的**值
`lead()` | 取排在当前行**之后的**值
-- | -x
`first_value()` | 指定区间范围内的第一行的值
`last_value()` | 指定区间范围内的最后一行的值
-- | -x
`nth_value()` | 指定区间范围内第`n`行的值
`ntile()` | 将数据分到`n`个桶，当前行所在的桶号

#### MySQL 窗口函数 - 排序函数
- 归类参考： https://dbaplus.cn/news-11-2258-1.html
- 数据准备
```sql
-- 建表
CREATE TABLE `emp` (
  `empno` int NOT NULL COMMENT '员工号',
  `ename` varchar(50) CHARACTER SET utf8mb4 COLLATE UTF8MB4_BIN DEFAULT NULL COMMENT '员工名',
  `deptno` int DEFAULT NULL COMMENT '部门号',
  `sal` decimal(10,2) DEFAULT NULL COMMENT '薪资',
  `hiredate` date DEFAULT NULL COMMENT '入职日期',
  PRIMARY KEY (`empno`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=UTF8MB4_BIN;
-- 插数据
INSERT INTO emp VALUES 
(11, 'A-11', 10, 12660, '2018-01-05'),
(12, 'A-12', 10, 12860, '2018-05-06'),
(13, 'A-13', 10, 12960, '2018-06-06'),
(14, 'A-14', 10, 12960, '2018-08-06'),
(15, 'A-15', 10, 12960, '2018-09-06'),
(21, 'B-21', 20, 22660, '2018-01-06'),
(22, 'B-22', 20, 22860, '2018-05-08'),
(23, 'B-23', 20, 22960, '2018-06-08'),
(24, 'B-24', 20, 22960, '2018-08-08'),
(31, 'C-31', 30, 32660, '2018-02-06'),
(32, 'C-32', 30, 32860, '2018-08-08'),
(33, 'C-33', 30, 32960, '2018-09-08'),
(34, 'C-34', 30, 32960, '2018-12-08');
-- 查看
SELECT * FROM emp;
```
- 测试
```sql
SELECT
  sal,
  ROW_NUMBER() OVER (ORDER BY sal) AS 'rn',
  RANK() OVER (ORDER BY sal) AS 'rk',
  DENSE_RANK() OVER (ORDER BY sal) AS 'dk'
FROM
  emp;
+----------+----+----+----+
| sal      | rn | rk | dk |
+----------+----+----+----+
| 12660.00 |  1 |  1 |  1 |
| 12860.00 |  2 |  2 |  2 |
| 12960.00 |  3 |  3 |  3 |
| 12960.00 |  4 |  3 |  3 |
| 12960.00 |  5 |  3 |  3 |
| 22660.00 |  6 |  6 |  4 |
| 22860.00 |  7 |  7 |  5 |
| 22960.00 |  8 |  8 |  6 |
| 22960.00 |  9 |  8 |  6 |
| 32660.00 | 10 | 10 |  7 |
| 32860.00 | 11 | 11 |  8 |
| 32960.00 | 12 | 12 |  9 |
| 32960.00 | 13 | 12 |  9 |
+----------+----+----+----+
13 rows in set (0.00 sec)
```
- **当出现重复值时**
- `ROW_NUMBER()` 不考虑重复值
  - 它会给相同的两个值分配不同的编号
  - 编号的范围是从 `1` 到分区的行数
- `RANK()` 和 `DENSE_RANK()` 给重复的值生成相同的编号
  - 不同的是，`RANK()` 生成的序号有间隙
    - 即重复值的下一项的编号和重复值的编号并不连续（`下一项的值的编号 = 当前重复值项的编号 + 1`）
  - 而 `DENSE_RANK()` 就不是这样

#### MySQL 窗口函数 - 指定分区
- https://dbaplus.cn/news-11-2258-1.html
- 如果没有指定 `partition by` 分区字段
  - 那么窗口函数操作的区间就是全部数据
  - 可以让函数只作用在 `deptno` 分区
```sql
SELECT
  sal, deptno,
  ROW_NUMBER() OVER (PARTITION BY deptno ORDER BY sal) AS 'rn'
FROM emp;
+----------+--------+----+
| sal      | deptno | rn |
+----------+--------+----+
| 12660.00 |     10 |  1 |
| 12860.00 |     10 |  2 |
| 12960.00 |     10 |  3 |
| 12960.00 |     10 |  4 |
| 12960.00 |     10 |  5 |
| 22660.00 |     20 |  1 |
| 22860.00 |     20 |  2 |
| 22960.00 |     20 |  3 |
| 22960.00 |     20 |  4 |
| 32660.00 |     30 |  1 |
| 32860.00 |     30 |  2 |
| 32960.00 |     30 |  3 |
| 32960.00 |     30 |  4 |
+----------+--------+----+
13 rows in set (0.00 sec)
```
- 获取 `emp` 表中每个部门工资最高的`前两名`员工的信息，可以 `ROW_NUMBER()`
```sql
SELECT * FROM (
  SELECT
    *, -- 所有列
    ROW_NUMBER() OVER (PARTITION BY deptno ORDER BY sal DESC) AS rn
  FROM emp
) t WHERE rn <= 2;
+-------+-------+--------+----------+------------+----+
| empno | ename | deptno | sal      | hiredate   | rn |
+-------+-------+--------+----------+------------+----+
|    13 | A-13  |     10 | 12960.00 | 2018-06-06 |  1 |
|    14 | A-14  |     10 | 12960.00 | 2018-08-06 |  2 |
|    23 | B-23  |     20 | 22960.00 | 2018-06-08 |  1 |
|    24 | B-24  |     20 | 22960.00 | 2018-08-08 |  2 |
|    33 | C-33  |     30 | 32960.00 | 2018-09-08 |  1 |
|    34 | C-34  |     30 | 32960.00 | 2018-12-08 |  2 |
+-------+-------+--------+----------+------------+----+
6 rows in set (0.00 sec)
```
- 注意，如果在 `OVER()` 中没有 `ORDER` 子句
  - 那么，`ROW_NUMBER()` 生成的编号是不确定的
  - 而 `RANK()`、`DENSE_RANK()` 生成的编号都是 `1`

#### MySQL 窗口函数 - 前后函数
- https://www.modb.pro/db/61070
```sql
SELECT 
  *,
  LAG(sal) OVER (ORDER BY empno) AS 'lag',
  LEAD(sal) OVER (ORDER BY empno) AS 'lead',
  LAG(sal, 2, 0) OVER (ORDER BY empno) AS 'lag_2'
FROM emp LIMIT 6;
+-------+-------+--------+----------+------------+----------+----------+----------+
| empno | ename | deptno | sal      | hiredate   | lag      | lead     | lag_2    |
+-------+-------+--------+----------+------------+----------+----------+----------+
|    11 | A-11  |     10 | 12660.00 | 2018-01-05 |     NULL | 12860.00 |     0.00 |
|    12 | A-12  |     10 | 12860.00 | 2018-05-06 | 12660.00 | 12960.00 |     0.00 |
|    13 | A-13  |     10 | 12960.00 | 2018-06-06 | 12860.00 | 12960.00 | 12660.00 |
|    14 | A-14  |     10 | 12960.00 | 2018-08-06 | 12960.00 | 12960.00 | 12860.00 |
|    15 | A-15  |     10 | 12960.00 | 2018-09-06 | 12960.00 | 22660.00 | 12960.00 |
|    21 | B-21  |     20 | 22660.00 | 2018-01-06 | 12960.00 | 22860.00 | 12960.00 |
+-------+-------+--------+----------+------------+----------+----------+----------+
6 rows in set (0.00 sec)
```
- `LAG()` 可以获得位于当前行之前的数据
  - 如果指定了分区，则获取数据的范围只能在分区内
  - 默认是获取上一条的记录，如果没有获取到，则返回 `NULL`
- `LAG()` 的表达式是 `LAG(expr [, N[, default]])`
  - 可以指定向后获取第 `N` 行
  - 以及在获取不到数据时指定默认值
- `LEAD()` 的表达式和 `LAG()` 是一样的
  - 因此在 `LEAD()` 中也可以指定获取的行数 `N` 及默认值

#### MySQL 窗口函数 - 头尾函数
- https://www.modb.pro/db/61070
```sql
SELECT 
  *,
  FIRST_VALUE(empno) OVER (
      PARTITION BY deptno 
      ORDER BY empno) AS 'first',
  LAST_VALUE(empno) OVER (
      PARTITION BY deptno ORDER BY empno 
      ROWS BETWEEN UNBOUNDED PRECEDING 
      AND UNBOUNDED FOLLOWING) AS 'last',
  NTH_VALUE(empno, 2) OVER (
      PARTITION BY deptno 
      ORDER BY empno) AS 'nth_2'
FROM emp;
+-------+-------+--------+----------+------------+-------+------+-------+
| empno | ename | deptno | sal      | hiredate   | first | last | nth_2 |
+-------+-------+--------+----------+------------+-------+------+-------+
|    11 | A-11  |     10 | 12660.00 | 2018-01-05 |    11 |   15 |  NULL |
|    12 | A-12  |     10 | 12860.00 | 2018-05-06 |    11 |   15 |    12 |
|    13 | A-13  |     10 | 12960.00 | 2018-06-06 |    11 |   15 |    12 |
|    14 | A-14  |     10 | 12960.00 | 2018-08-06 |    11 |   15 |    12 |
|    15 | A-15  |     10 | 12960.00 | 2018-09-06 |    11 |   15 |    12 |
|    21 | B-21  |     20 | 22660.00 | 2018-01-06 |    21 |   24 |  NULL |
|    22 | B-22  |     20 | 22860.00 | 2018-05-08 |    21 |   24 |    22 |
|    23 | B-23  |     20 | 22960.00 | 2018-06-08 |    21 |   24 |    22 |
|    24 | B-24  |     20 | 22960.00 | 2018-08-08 |    21 |   24 |    22 |
|    31 | C-31  |     30 | 32660.00 | 2018-02-06 |    31 |   34 |  NULL |
|    32 | C-32  |     30 | 32860.00 | 2018-08-08 |    31 |   34 |    32 |
|    33 | C-33  |     30 | 32960.00 | 2018-09-08 |    31 |   34 |    32 |
|    34 | C-34  |     30 | 32960.00 | 2018-12-08 |    31 |   34 |    32 |
+-------+-------+--------+----------+------------+-------+------+-------+
13 rows in set (0.00 sec)
```
- 这几个函数可以分别获取区间范围内`第一行、最后一行、第 N 行`的值
- 当在 `OVER()` 中指定了排序字段，
  - `FIRST_VALUE()、LAST_VALUE()、NTH_VALUE()`
    - 这几个函数的滑动窗口范围是从第一行到当前行
    - （即 `range between unbounded preceding and current row`）
  - 直接使用 `LAST_VALUE()` 得到的结果并不是想看到的那样
    - 因此，需要把 `LAST_VALUE()` 的窗口范围改成 `range between unbounded preceding and unbounded following`

#### MySQL 窗口函数 - `ntile` 函数
- https://www.modb.pro/db/61070
- 将一个分区划分为 `N` 个组（桶）
  - 给分区中的每一行分配其桶号
  - 并返回其分区中当前行的桶号
```sql
SELECT 
  *, -- 下面是分 2 个桶，所有只有 1, 2
  NTILE(2) OVER (PARTITION BY deptno ORDER BY empno) AS ntile2
FROM emp;
+-------+-------+--------+----------+------------+--------+
| empno | ename | deptno | sal      | hiredate   | ntile2 |
+-------+-------+--------+----------+------------+--------+
|    11 | A-11  |     10 | 12660.00 | 2018-01-05 |      1 |
|    12 | A-12  |     10 | 12860.00 | 2018-05-06 |      1 |
|    13 | A-13  |     10 | 12960.00 | 2018-06-06 |      1 |
|    14 | A-14  |     10 | 12960.00 | 2018-08-06 |      2 |
|    15 | A-15  |     10 | 12960.00 | 2018-09-06 |      2 |
|    21 | B-21  |     20 | 22660.00 | 2018-01-06 |      1 |
|    22 | B-22  |     20 | 22860.00 | 2018-05-08 |      1 |
|    23 | B-23  |     20 | 22960.00 | 2018-06-08 |      2 |
|    24 | B-24  |     20 | 22960.00 | 2018-08-08 |      2 |
|    31 | C-31  |     30 | 32660.00 | 2018-02-06 |      1 |
|    32 | C-32  |     30 | 32860.00 | 2018-08-08 |      1 |
|    33 | C-33  |     30 | 32960.00 | 2018-09-08 |      2 |
|    34 | C-34  |     30 | 32960.00 | 2018-12-08 |      2 |
+-------+-------+--------+----------+------------+--------+
13 rows in set (0.00 sec)
```

#### MySQL 窗口函数 - `cume_dist` 函数
- https://www.modb.pro/db/61070
- 统计一组数据中**小于等于**（或大于等于，和 `OVER()` 中指定的排序行为有关系）当前行的值的百分比
```sql
SELECT 
  *,
  ROW_NUMBER() OVER (ORDER BY sal) AS rn,
  CUME_DIST() OVER (ORDER BY sal) AS dist
FROM emp;
+-------+-------+--------+----------+------------+----+---------------------+
| empno | ename | deptno | sal      | hiredate   | rn | dist                |
+-------+-------+--------+----------+------------+----+---------------------+
|    11 | A-11  |     10 | 12660.00 | 2018-01-05 |  1 | 0.07692307692307693 |
|    12 | A-12  |     10 | 12860.00 | 2018-05-06 |  2 | 0.15384615384615385 |
|    13 | A-13  |     10 | 12960.00 | 2018-06-06 |  3 | 0.38461538461538464 |
|    14 | A-14  |     10 | 12960.00 | 2018-08-06 |  4 | 0.38461538461538464 |
|    15 | A-15  |     10 | 12960.00 | 2018-09-06 |  5 | 0.38461538461538464 |
|    21 | B-21  |     20 | 22660.00 | 2018-01-06 |  6 | 0.46153846153846156 |
|    22 | B-22  |     20 | 22860.00 | 2018-05-08 |  7 |  0.5384615384615384 |
|    23 | B-23  |     20 | 22960.00 | 2018-06-08 |  8 |  0.6923076923076923 |
|    24 | B-24  |     20 | 22960.00 | 2018-08-08 |  9 |  0.6923076923076923 |
|    31 | C-31  |     30 | 32660.00 | 2018-02-06 | 10 |  0.7692307692307693 |
|    32 | C-32  |     30 | 32860.00 | 2018-08-08 | 11 |  0.8461538461538461 |
|    33 | C-33  |     30 | 32960.00 | 2018-09-08 | 12 |                   1 |
|    34 | C-34  |     30 | 32960.00 | 2018-12-08 | 13 |                   1 |
+-------+-------+--------+----------+------------+----+---------------------+
13 rows in set (0.00 sec)
```
- 当在 `OVER()` 指定排序的行为是 `ORDER BY sal DESC` 时，看到的将是另一番景象
```sql
SELECT 
  *,
  ROW_NUMBER() OVER (ORDER BY sal DESC) AS rn,
  CUME_DIST() OVER (ORDER BY sal DESC) AS dist
FROM emp ORDER BY empno ASC;
+-------+-------+--------+----------+------------+----+---------------------+
| empno | ename | deptno | sal      | hiredate   | rn | dist                |
+-------+-------+--------+----------+------------+----+---------------------+
|    11 | A-11  |     10 | 12660.00 | 2018-01-05 | 13 |                   1 |
|    12 | A-12  |     10 | 12860.00 | 2018-05-06 | 12 |  0.9230769230769231 |
|    13 | A-13  |     10 | 12960.00 | 2018-06-06 |  9 |  0.8461538461538461 |
|    14 | A-14  |     10 | 12960.00 | 2018-08-06 | 10 |  0.8461538461538461 |
|    15 | A-15  |     10 | 12960.00 | 2018-09-06 | 11 |  0.8461538461538461 |
|    21 | B-21  |     20 | 22660.00 | 2018-01-06 |  8 |  0.6153846153846154 |
|    22 | B-22  |     20 | 22860.00 | 2018-05-08 |  7 |  0.5384615384615384 |
|    23 | B-23  |     20 | 22960.00 | 2018-06-08 |  5 | 0.46153846153846156 |
|    24 | B-24  |     20 | 22960.00 | 2018-08-08 |  6 | 0.46153846153846156 |
|    31 | C-31  |     30 | 32660.00 | 2018-02-06 |  4 |  0.3076923076923077 |
|    32 | C-32  |     30 | 32860.00 | 2018-08-08 |  3 | 0.23076923076923078 |
|    33 | C-33  |     30 | 32960.00 | 2018-09-08 |  1 | 0.15384615384615385 |
|    34 | C-34  |     30 | 32960.00 | 2018-12-08 |  2 | 0.15384615384615385 |
+-------+-------+--------+----------+------------+----+---------------------+
13 rows in set (0.00 sec)
```

#### MySQL 窗口函数 - `percent_rank` 函数
- https://www.modb.pro/db/61070
- `PERCENT_RANK()` 和 `CUME_DIST()` 一样
  - 也是统计某个值的分配情况，只是它们的算法不一样
  - `PERCENT_RANK()` 的计算公式：`(rank - 1) / (rows - 1)`
  - 其中，`rank` 表示行的等级（如果出现重复值，则用最小的那个编号）
  - `rows` 表示分区的行数
```sql
SELECT 
  *,
  RANK() OVER (ORDER BY sal) AS rk,
  PERCENT_RANK() OVER (ORDER BY sal) AS percent
FROM emp;
+-------+-------+--------+----------+------------+----+---------------------+
| empno | ename | deptno | sal      | hiredate   | rk | percent             |
+-------+-------+--------+----------+------------+----+---------------------+
|    11 | A-11  |     10 | 12660.00 | 2018-01-05 |  1 |                   0 |
|    12 | A-12  |     10 | 12860.00 | 2018-05-06 |  2 | 0.08333333333333333 |
|    13 | A-13  |     10 | 12960.00 | 2018-06-06 |  3 | 0.16666666666666666 |
|    14 | A-14  |     10 | 12960.00 | 2018-08-06 |  3 | 0.16666666666666666 |
|    15 | A-15  |     10 | 12960.00 | 2018-09-06 |  3 | 0.16666666666666666 |
|    21 | B-21  |     20 | 22660.00 | 2018-01-06 |  6 |  0.4166666666666667 |
|    22 | B-22  |     20 | 22860.00 | 2018-05-08 |  7 |                 0.5 |
|    23 | B-23  |     20 | 22960.00 | 2018-06-08 |  8 |  0.5833333333333334 |
|    24 | B-24  |     20 | 22960.00 | 2018-08-08 |  8 |  0.5833333333333334 |
|    31 | C-31  |     30 | 32660.00 | 2018-02-06 | 10 |                0.75 |
|    32 | C-32  |     30 | 32860.00 | 2018-08-08 | 11 |  0.8333333333333334 |
|    33 | C-33  |     30 | 32960.00 | 2018-09-08 | 12 |  0.9166666666666666 |
|    34 | C-34  |     30 | 32960.00 | 2018-12-08 | 12 |  0.9166666666666666 |
+-------+-------+--------+----------+------------+----+---------------------+
13 rows in set (0.00 sec)
```
- 说明：`22: B-22 = (7 - 1) / (13 - 1) = 0.5`

#### MySQL 聚合窗口函数
- https://www.modb.pro/db/61070
- 在下面这些**聚合函数后面加上 `OVER()` 子句**
  - 就**变成聚合窗口函数**
```sql
-- 常用的
AVG(), COUNT(), MAX(), MIN(), SUM()
-- 非常用的
BIT_AND(), BIT_OR(), BIT_XOR()
JSON_ARRAYAGG()
JSON_OBJECTAGG()
STDDEV_POP(), STDDEV(), STD(), STDDEV_SAMP()
VAR_POP(), VARIANCE(), VAR_SAMP()
```
- 下面这个例子，它利用窗口函数只查一次 `emp` 表完成了这些需求：
  - 统计所有员工的薪资
  - 统计每个部门的人数
  - 计算每个部门的平均薪资
  - 获取公司里面的最高薪资
  - 获取最早入职的员工的入职时间
```sql
SELECT 
  empno, ename, deptno, sal,
  SUM(sal) OVER () AS '总薪',
  COUNT(*) OVER (PARTITION BY deptno) AS '部门人数',
  AVG(sal) OVER (PARTITION BY deptno) AS '部门均薪',
  MAX(sal) OVER () AS '最高薪',
  MIN(hiredate) OVER () '最早入职'
FROM emp;
+-------+-------+--------+----------+-----------+---------+----------+----------+-----------+
| empno | ename | deptno | sal      | 总薪      | 部门人数 | 部门均薪  | 最高薪   | 最早入职   |
+-------+-------+--------+----------+-----------+---------+----------+----------+-----------+
|    11 | A-11  |     10 | 12660.00 | 287280.00 |       5 | 12880.00 | 32960.00 | 2018-01-05 |
|    12 | A-12  |     10 | 12860.00 | 287280.00 |       5 | 12880.00 | 32960.00 | 2018-01-05 |
|    13 | A-13  |     10 | 12960.00 | 287280.00 |       5 | 12880.00 | 32960.00 | 2018-01-05 |
|    14 | A-14  |     10 | 12960.00 | 287280.00 |       5 | 12880.00 | 32960.00 | 2018-01-05 |
|    15 | A-15  |     10 | 12960.00 | 287280.00 |       5 | 12880.00 | 32960.00 | 2018-01-05 |
|    21 | B-21  |     20 | 22660.00 | 287280.00 |       4 | 22860.00 | 32960.00 | 2018-01-05 |
|    22 | B-22  |     20 | 22860.00 | 287280.00 |       4 | 22860.00 | 32960.00 | 2018-01-05 |
|    23 | B-23  |     20 | 22960.00 | 287280.00 |       4 | 22860.00 | 32960.00 | 2018-01-05 |
|    24 | B-24  |     20 | 22960.00 | 287280.00 |       4 | 22860.00 | 32960.00 | 2018-01-05 |
|    31 | C-31  |     30 | 32660.00 | 287280.00 |       4 | 32860.00 | 32960.00 | 2018-01-05 |
|    32 | C-32  |     30 | 32860.00 | 287280.00 |       4 | 32860.00 | 32960.00 | 2018-01-05 |
|    33 | C-33  |     30 | 32960.00 | 287280.00 |       4 | 32860.00 | 32960.00 | 2018-01-05 |
|    34 | C-34  |     30 | 32960.00 | 287280.00 |       4 | 32860.00 | 32960.00 | 2018-01-05 |
+-------+-------+--------+----------+-----------+---------+----------+----------+-----------+
13 rows in set (0.00 sec)
```

#### MySQL 命名窗口函数
- https://www.modb.pro/db/61070
- 可以用 `WINDOWS` 关键字给窗口起别名
  - 并在 `OVER()` 中引用它
- 命名窗口子句位于 `HAVING` 子句和 `ORDER` 子句的位置之间
  - 其语法如下：
```sql
WINDOW window_name AS (window_spec)
    [, window_name AS (window_spec)]
-- window_spec 的定义
window_spec:
    [window_name][partition_clause][order_clause][frame_clause]
```
- 示例：
```sql
-- 简单的
SELECT
  sal,
  ROW_NUMBER() OVER w AS 'row_number',
  RANK()       OVER w AS 'rank',
  DENSE_RANK() OVER w AS 'dense_rank'
FROM emp
WINDOW w AS (ORDER BY sal);

-- 复杂的
SELECT
  deptno, sal,
  ROW_NUMBER() OVER w2 AS 'row_number',
  RANK()       OVER (w1 ORDER BY sal) AS 'rank',
  DENSE_RANK() OVER w3 AS 'dense_rank'
FROM emp
WINDOW w1 AS(PARTITION BY deptno),
       w2 AS(ORDER BY sal),
       w3 AS(w2)
ORDER BY sal DESC;
```

#### MySQL 动态窗口 `frame`
- https://www.modb.pro/db/61070
- `FRAME` 子句的就是用来实现动态窗口
- 窗口函数在每行记录上执行
  - 有的函数的**窗口不会发生变化**，这种就**属于静态窗口**
  - 有的函数**随着记录不同，窗口大小也在不断变化**，这种就**属于动态窗口**
- 下面例子，通过滑动窗口实现随着时间的变化累加部门的薪资
  - 以及计算当前行和上下行记录的平均薪资
```sql
SELECT 
  *,
  SUM(sal) OVER (PARTITION BY deptno 
    ORDER BY hiredate 
    ROWS UNBOUNDED PRECEDING) AS total,
  AVG(sal) OVER (
    PARTITION BY deptno 
    ORDER BY hiredate 
    ROWS BETWEEN 1 PRECEDING 
      AND 1 FOLLOWING) AS average
FROM emp;
+-------+-------+--------+----------+------------+-----------+--------------+
| empno | ename | deptno | sal      | hiredate   | total     | average      |
+-------+-------+--------+----------+------------+-----------+--------------+
|    11 | A-11  |     10 | 12660.00 | 2018-01-05 |  12660.00 | 12760.000000 |
|    12 | A-12  |     10 | 12860.00 | 2018-05-06 |  25520.00 | 12826.666667 |
|    13 | A-13  |     10 | 12960.00 | 2018-06-06 |  38480.00 | 12926.666667 |
|    14 | A-14  |     10 | 12960.00 | 2018-08-06 |  51440.00 | 12960.000000 |
|    15 | A-15  |     10 | 12960.00 | 2018-09-06 |  64400.00 | 12960.000000 |
|    21 | B-21  |     20 | 22660.00 | 2018-01-06 |  22660.00 | 22760.000000 |
|    22 | B-22  |     20 | 22860.00 | 2018-05-08 |  45520.00 | 22826.666667 |
|    23 | B-23  |     20 | 22960.00 | 2018-06-08 |  68480.00 | 22926.666667 |
|    24 | B-24  |     20 | 22960.00 | 2018-08-08 |  91440.00 | 22960.000000 |
|    31 | C-31  |     30 | 32660.00 | 2018-02-06 |  32660.00 | 32760.000000 |
|    32 | C-32  |     30 | 32860.00 | 2018-08-08 |  65520.00 | 32826.666667 |
|    33 | C-33  |     30 | 32960.00 | 2018-09-08 |  98480.00 | 32926.666667 |
|    34 | C-34  |     30 | 32960.00 | 2018-12-08 | 131440.00 | 32960.000000 |
+-------+-------+--------+----------+------------+-----------+--------------+
13 rows in set (0.00 sec)
```
- 说明：
  - 当计算 `empno = 11` 这行记录时
    - `total = 12660, average = (12660 + 12860) / 2 = 12760;`
  - 当计算 `empno = 12` 这行记录时
    - `total = 12660 + 12860 = 25520, average = (12660 + 12860 + 12960) / 3 = 12826.66;`
  - 当计算 `empno = 13` 这行记录时
    - `total = 12660 + 12860 + 12960 = 38480, average = (12860 + 12960 + 12960) / 3 = 12926.66;`
- 可以通过基于行或者基于范围的方式指定窗口的大小
  - 基于行：选择当前行的前后几行
    - 比如范围是当前行的往前两行和往后三行
    - 就可以这么写语句 `ROWS BETWEEN 2 PRECEDING AND 3 FOLLOWING`
  - 基于范围：选择数据范围
    - 例如获取值在区间 `[c - 2，c + 3]` 的数据
    - 语句就是 `RANGE BETWEEN 2 PRECEDING AND 3 FOLLOWING`，`c` 表示当前行的值
    - 典型的应用场景是统计每天的日活、月活，这些用基于行的方式不好表示
