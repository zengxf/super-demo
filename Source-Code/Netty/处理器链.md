## 处理器链
- 每个信道都有一个流水线 `ChannelPipeline`
  - 默认实现类为 `DefaultChannelPipeline`
- 默认流水线内部封装上下文 `ChannelHandlerContext`
  - 上下文默认实现类为 `DefaultChannelHandlerContext`
  - 相当于是双向链表（节点数据为处理器 `ChannelHandler`）

### DefaultChannelPipeline
- `io.netty.channel.DefaultChannelPipeline`
- 添加节点
  - 参考：[简单示例-服务端 sign_demo_010](简单示例.md#服务端)
```java
/*** 默认信道流水线 */
public class DefaultChannelPipeline implements ChannelPipeline {
    final HeadContext head; // 头节点
    final TailContext tail; // 尾节点
    private final Channel channel; // 信道

    // 构造器（在创建信道时调用）
    protected DefaultChannelPipeline(Channel channel) {
        this.channel = ObjectUtil.checkNotNull(channel, "channel");
        ...

        tail = new TailContext(this);
        head = new HeadContext(this);

        head.next = tail;
        tail.prev = head;
    }

    // sign_demo_010 添加到尾部
    @Override
    public final ChannelPipeline addLast(String name, ChannelHandler handler) {
        return addLast(null, name, handler); // sign_m_001 添加到尾部并设置线程
    }

    /**
     * sign_m_001 添加到尾部并设置线程
     * 
     * group 为空则不设置线程，不为空则提取一个线程设置给节点
     */
    @Override 
    public final ChannelPipeline addLast(EventExecutorGroup group, String name, ChannelHandler handler) {
        final AbstractChannelHandlerContext newCtx;
        synchronized (this) {
            /**
             * 校验 handler 是否重复添加。
             * 如果 handler 需要被重复添加到流水线，则需要加 @Sharable 注解
             */
            checkMultiplicity(handler);

            newCtx = newContext(group, filterName(name, handler), handler); // sign_m_002 创建上下文节点

            addLast0(newCtx); // sign_m_003 添加到尾部

            ... // 未注册挂起与异步调用钩子函数处理
        }
        callHandlerAdded0(newCtx); // sign_m_004 回调 handler 钩子函数 handlerAdded(ctx)
        return this;
    }

    // sign_m_002 创建上下文节点
    private AbstractChannelHandlerContext newContext(EventExecutorGroup group, String name, ChannelHandler handler) {
        return new DefaultChannelHandlerContext(this, childExecutor(group), name, handler); // sign_m_010 将 handler 封装到节点里
    }

    // sign_m_003 添加到尾部（但在尾节点之前）
    private void addLast0(AbstractChannelHandlerContext newCtx) {
        /**
         * 相当于链结构由：
         *   ... <-> prev <-> tail
         * 变成：
         *   ... <-> prev <-> newCtx <-> tail
         */
        AbstractChannelHandlerContext prev = tail.prev;
        newCtx.prev = prev;
        newCtx.next = tail;
        prev.next = newCtx;
        tail.prev = newCtx;
    }

    // sign_m_004 回调 handler 钩子函数 handlerAdded(ctx)
    private void callHandlerAdded0(final AbstractChannelHandlerContext ctx) {
        try {
            ctx.callHandlerAdded();
        } ... // catch
    }
}
```

### DefaultChannelHandlerContext
- `io.netty.channel.DefaultChannelHandlerContext`
```java
/*** 默认处理器上下文（相当于双链表节点） */
final class DefaultChannelHandlerContext extends AbstractChannelHandlerContext {
    private final ChannelHandler handler; // 封装的处理器

    // sign_m_010 将 handler 封装到节点里
    DefaultChannelHandlerContext(
            DefaultChannelPipeline pipeline, EventExecutor executor, String name, ChannelHandler handler
    ) {
        // executor 相当于线程
        super(pipeline, executor, name, handler.getClass()); // sign_m_020
        this.handler = handler;
    }

    @Override
    public ChannelHandler handler() {
        return handler;
    }
}
```

- `io.netty.channel.AbstractChannelHandlerContext`
```java
// 上下文节点父类
abstract class AbstractChannelHandlerContext implements ChannelHandlerContext, ResourceLeakHint {
    volatile AbstractChannelHandlerContext next;    // 下一个节点
    volatile AbstractChannelHandlerContext prev;    // 上一个节点
    private final DefaultChannelPipeline pipeline;  // 用于反查流水线
    private final String name; // 如果未指定，则默认用处理器类简名 + "#0" 进行赋值
    final EventExecutor executor;

    // sign_m_020
    AbstractChannelHandlerContext(DefaultChannelPipeline pipeline, EventExecutor executor,
                                  String name, Class<? extends ChannelHandler> handlerClass
    ) {
        this.name = ObjectUtil.checkNotNull(name, "name");
        this.pipeline = pipeline;
        this.executor = executor;
        ... // 其他设置
    }

    /**
     * sign_f_001 执行线程
     * 
     * 用于执行当前处理器的相关方法，
     * 如果为空（未指定），则用信道的线程执行。
     */
    @Override
    public EventExecutor executor() {
        if (executor == null) {
            return channel().eventLoop();
        } else {
            return executor;
        }
    }
}
```

### 读流程
- `io.netty.channel.DefaultChannelPipeline`
  - 调用点-参考：[读写原理-读原理 sign_o_010](读写原理.md#读原理)
```java
/*** 默认信道流水线 */
public class DefaultChannelPipeline implements ChannelPipeline {
    // sign_o_010 发送读取的字节
    @Override
    public final ChannelPipeline fireChannelRead(Object msg) {
        AbstractChannelHandlerContext.invokeChannelRead(head, msg);     // sign_m_101 使用头节点读
        return this;
    }

    // sign_o_020 发送读取完成事件
    @Override
    public final ChannelPipeline fireChannelReadComplete() {
        AbstractChannelHandlerContext.invokeChannelReadComplete(head);  // sign_m_110 从头节点开始
        return this;
    }

    /*** 头节点 */
    final class HeadContext extends AbstractChannelHandlerContext
                            implements ChannelOutboundHandler, ChannelInboundHandler
    {
        // sign_m_130 读
        @Override
        public void channelRead(ChannelHandlerContext ctx, Object msg) {
            ctx.fireChannelRead(msg); // sign_m_131 上下文读
        }
    }
}
```

- `io.netty.channel.AbstractChannelHandlerContext`
```java
abstract class AbstractChannelHandlerContext implements ChannelHandlerContext, ResourceLeakHint {
    // sign_m_101 开启读调用
    static void invokeChannelRead(final AbstractChannelHandlerContext next, Object msg) {
        final Object m = next.pipeline.touch(ObjectUtil.checkNotNull(msg, "msg"), next);
        EventExecutor executor = next.executor();   // sign_f_001
        if (executor.inEventLoop()) {
            next.invokeChannelRead(m);              // sign_i_102 使用（当前类的）实例方法进行读
        } else {
            ... // 用给定的线程执行 invokeChannelRead(m) 方法
        }
    }

    // sign_i_102 读处理
    private void invokeChannelRead(Object msg) {
        if (invokeHandler()) {
            try {
                // see https://bugs.openjdk.org/browse/JDK-8180450
                final ChannelHandler handler = handler();
                final DefaultChannelPipeline.HeadContext headContext = pipeline.head;
                if (handler == headContext) {
                    headContext.channelRead(this, msg); // sign_m_130 头节点处理读
                } else if (handler instanceof ChannelDuplexHandler) {
                    ((ChannelDuplexHandler) handler).channelRead(this, msg);
                } else {
                    ((ChannelInboundHandler) handler).channelRead(this, msg); // 其他入站处理器处理
                }
            } ... // catch
        } ... // else 
    }

    // sign_m_110 开启调用
    static void invokeChannelReadComplete(final AbstractChannelHandlerContext next) {
        EventExecutor executor = next.executor();   // sign_f_001
        if (executor.inEventLoop()) {
            next.invokeChannelReadComplete();       // 当前类的实例方法。具体实现略...
        } else {
            ... // 相当于用给定的线程执行 invokeChannelReadComplete() 方法
        }
    }

    // sign_m_131 读处理（链式调用处理）
    @Override
    public ChannelHandlerContext fireChannelRead(final Object msg) {
        /**
         * sign_m_132 findContextInbound 查找下一个节点
         * sign_m_101 invokeChannelRead  开启读调用
         */
        invokeChannelRead(findContextInbound(MASK_CHANNEL_READ), msg);
        return this;
    }

    // sign_m_132 查找链表上的入站处理器节点
    private AbstractChannelHandlerContext findContextInbound(int mask) {
        AbstractChannelHandlerContext ctx = this;
        EventExecutor currentExecutor = executor();
        do {
            ctx = ctx.next;
        } while (skipContext(ctx, currentExecutor, mask, MASK_ONLY_INBOUND));
        return ctx;
    }
}
```

### 写流程



---
## 处理器回调函数逻辑


---
## @Skip-原理