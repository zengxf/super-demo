## 介绍
- 参考 `NioEventLoop`
- 主要逻辑为：死循环监听 `selector`


## 原理
- `io.netty.channel.nio.NioEventLoop`
```java
/*** NIO 事件轮循 */
public final class NioEventLoop extends SingleThreadEventLoop {
    private Selector selector;              // 封装的选择器。可参考：#openSelector()
    private Selector unwrappedSelector;     // JDK 底层选择器
    private SelectedSelectionKeySet selectedKeys;
    private final SelectorProvider provider;// 选择器 SPI 提供者

    /*** 可理解为线程的 Runnable #run() 方法 */
    @Override
    protected void run() {
        for (;;) { // 死循环监听
            try {
                int strategy;
                try {
                    strategy = selectStrategy.calculateStrategy(selectNowSupplier, hasTasks());
                    switch (strategy) {
                    ... // 省略其他 case
                    case SelectStrategy.SELECT:
                        long curDeadlineNanos = ... // 一般设置为 NONE
                        ...
                        try {
                            if (!hasTasks()) {
                                strategy = select(curDeadlineNanos); // select 监听
                            }
                        } ... // finally
                    default:
                    }
                } catch (IOException e) {
                    rebuildSelector0(); // 有错误，重新构建选择器并将信道注册进去
                    ...
                    continue;
                }

                ...

                if (ioRatio == 100) {
                    ...
                } else if (strategy > 0) {
                    try {
                        processSelectedKeys(); // 处理 keys
                    } ... // finally
                } else {
                    ranTasks = runAllTasks(0); // This will run the minimum number of tasks
                }

                ...
            } ... // catch finally
        }
    }

    /*** 监听 */
    private int select(long deadlineNanos) throws IOException {
        if (deadlineNanos == NONE) {
            return selector.select(); // 相当于底层监听
        }
        long timeoutMillis = deadlineToDelayNanos(deadlineNanos + 995000L) / 1000000L;
        return timeoutMillis <= 0 ? selector.selectNow() : selector.select(timeoutMillis); // 限时监听
    }

    /*** 处理 keys */
    private void processSelectedKeys() {
        if (selectedKeys != null) {
            processSelectedKeysOptimized();
        } else {
            processSelectedKeysPlain(selector.selectedKeys()); // 处理 keys
        }
    }
    
    /*** 处理 keys */
    private void processSelectedKeysPlain(Set<SelectionKey> selectedKeys) {
        ... // 校验空

        Iterator<SelectionKey> i = selectedKeys.iterator();
        for (;;) {
            final SelectionKey k = i.next();
            final Object a = k.attachment();
            i.remove(); // 需要移除（可参考 JDK-示例）

            if (a instanceof AbstractNioChannel) {
                processSelectedKey(k, (AbstractNioChannel) a); // 处理单个 key
            } ... // else

            ... // 没有下一项，退出循环
            ... // needsToSelectAgain(再次选择)处理
        }
    }

    /*** 处理单个 key */
    private void processSelectedKey(SelectionKey k, AbstractNioChannel ch) {
        final AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();
        ... // key 无效处理

        try {
            int readyOps = k.readyOps();
            if ((readyOps & SelectionKey.OP_CONNECT) != 0) { // 客户端连接事件
                int ops = k.interestOps();
                ops &= ~SelectionKey.OP_CONNECT;
                k.interestOps(ops);     // 重置 key 的兴趣事件
                unsafe.finishConnect(); // 相当于 sc.finishConnect()，等待连接完成
            }
            if ((readyOps & SelectionKey.OP_WRITE) != 0) { // 写事件
               unsafe.forceFlush(); // 出站处理
            }
            if ((readyOps & (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == 0) { // 读事件
                unsafe.read();      // 入站处理
            }
        } ... // catch 
    }
}
```