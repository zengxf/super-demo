## 使用示例
- https://github.com/zengxf/small-frame-demo/blob/master/multi-thread/reactive-test/reactor-demo/src/main/java/cn/zxf/reactor_demo/jdk/PubSubTest.java


## JDK 版本
```js
openjdk version "17" 2021-09-14
OpenJDK Runtime Environment (build 17+35-2724)
OpenJDK 64-Bit Server VM (build 17+35-2724, mixed mode, sharing)
```


## 原理
### 关键类
- `java.util.concurrent.SubmissionPublisher`
```java
// 提交式-发布者
public class SubmissionPublisher<T> implements Publisher<T>, AutoCloseable {
    BufferedSubscription<T> clients;    // 客户端（BufferedSubscriptions）链表
    final ReentrantLock lock;           // 锁定以排除多个源
    volatile boolean closed;            // 运行状态，仅在锁内更新
    boolean subscribed; // 在第一次调用订阅时设置 true，以初始化可能的拥有者
    Thread owner;       // 第一个要订阅的调用者线程，如果线程发生更改则为 null
    volatile Throwable closedException; // closeExceptionally 中的异常
    final Executor executor;            // 用于构造 BufferedSubscriptions 的参数
    final BiConsumer<? super Subscriber<? super T>, ? super Throwable> onNextHandler;
    final int maxBufferCapacity;

    // 调用入口 ref: sign_demo_001
    public SubmissionPublisher() {
        this(ASYNC_POOL, Flow.defaultBufferSize(), null);   // ref: sign_cm_002
    }

    // sign_cm_002
    public SubmissionPublisher(
        Executor executor, int maxBufferCapacity,
        BiConsumer<? super Subscriber<? super T>, ? super Throwable> handler
    ) {
        ... // 参数校验
        this.lock = new ReentrantLock();
        this.executor = executor;   // def: ForkJoinPool
        this.onNextHandler = handler;
        this.maxBufferCapacity = roundCapacity(maxBufferCapacity);  // def: 256
    }
}
```

### 订阅
- `java.util.concurrent.SubmissionPublisher`
```java
    // 订阅（添加订阅者）。调用入口 ref: sign_demo_010
    public void subscribe(Subscriber<? super T> subscriber) {
        if (subscriber == null) throw new NullPointerException();
        ReentrantLock lock = this.lock;
        int max = maxBufferCapacity;
        // INITIAL_CAPACITY = 32, 默认情况下计算完数组长度为 32
        Object[] array = new Object[max < INITIAL_CAPACITY ? max : INITIAL_CAPACITY]; 
        // 初始化订阅关系，ref: sign_c_110 | sign_cm_110
        BufferedSubscription<T> subscription = new BufferedSubscription<T>(
            subscriber, executor, onNextHandler, array, max
        );
        lock.lock();
        try {
            if (!subscribed) {
                subscribed = true;
                owner = Thread.currentThread();
            }
            for (BufferedSubscription<T> b = clients, pred = null;;) {
                if (b == null) {    // 还没有初始化链
                    Throwable ex;
                    subscription.onSubscribe();
                    if ((ex = closedException) != null)
                        subscription.onError(ex);   // 有异常
                    else if (closed)
                        subscription.onComplete();  // 已关闭
                    else if (pred == null)
                        clients = subscription;     // 初始化链
                    else
                        pred.next = subscription;   // 加入链
                    break;
                }
                BufferedSubscription<T> next = b.next;
                if (b.isClosed()) {   // remove
                    b.next = null;    // detach
                    if (pred == null)
                        clients = next;
                    else
                        pred.next = next;
                }
                else if (subscriber.equals(b.subscriber)) {
                    // 不能重复添加
                    b.onError(new IllegalStateException("Duplicate subscribe"));
                    break;
                }
                else
                    pred = b;   // 方便后面的加入链
                b = next;       // 方便遍历链
            }
        } finally {
            lock.unlock();
        }
    }
```

- `java.util.concurrent.SubmissionPublisher.BufferedSubscription`
```java
    // sign_c_110 订阅关系
    static final class BufferedSubscription<T> implements Subscription, ForkJoinPool.ManagedBlocker {
        long timeout;                      // Long.MAX_VALUE if untimed wait
        int head;                          // next position to take
        int tail;                          // next position to put
        final int maxCapacity;             // max buffer size
        volatile int ctl;                  // atomic run state flags
        Object[] array;                    // buffer
        final Subscriber<? super T> subscriber;
        final BiConsumer<? super Subscriber<? super T>, ? super Throwable> onNextHandler;
        Executor executor;                 // null on error

        BufferedSubscription<T> next;      // 组装链 

        // sign_cm_110
        BufferedSubscription(
            Subscriber<? super T> subscriber,   // 自定义的订阅者
            Executor executor,      // ForkJoinPool
            BiConsumer<? super Subscriber<? super T>, ? super Throwable> onNextHandler, // null
            Object[] array,         // len: 32
            int maxBufferCapacity   // 256
        ) {
            this.subscriber = subscriber;
            this.executor = executor;
            this.onNextHandler = onNextHandler;
            this.array = array;
            this.maxCapacity = maxBufferCapacity;
        }
    }
```

### 提交数据
- `java.util.concurrent.SubmissionPublisher`
```java
    // 提交数据。调用入口 ref: sign_demo_020
    public int submit(T item) {
        return doOffer(item, Long.MAX_VALUE, null); // ref: sign_m_210
    }

    // sign_m_210
    private int doOffer(T item, long nanos, BiPredicate<Subscriber<? super T>, ? super T> onDrop) {
        if (item == null) throw new NullPointerException();
        int lag = 0;
        boolean complete, unowned;
        ReentrantLock lock = this.lock;
        lock.lock();
        try {
            Thread t = Thread.currentThread(), o;
            BufferedSubscription<T> b = clients;
            if ((unowned = ((o = owner) != t)) && o != null)
                owner = null;                     // disable bias
            if (b == null)
                complete = closed;
            else {  // 有订阅者才做处理
                complete = false;
                boolean cleanMe = false;
                BufferedSubscription<T> retries = null, rtail = null, next;
                do {
                    next = b.next;
                    int stat = b.offer(item, unowned);  // 依次发给订阅者句柄，ref: sign_m_220
                    ...
                } while ((b = next) != null);   // 遍历链

                ...
            }
        } finally {
            lock.unlock();
        }
        ...
    }
```

- `java.util.concurrent.SubmissionPublisher.BufferedSubscription`
```java
        // sign_m_220 添加到队列
        final int offer(T item, boolean unowned) {
            Object[] a;
            int stat = 0, cap = ((a = array) == null) ? 0 : a.length;
            int t = tail, i = t & (cap - 1), n = t + 1 - head;
            if (cap > 0) {
                boolean added;
                if (n >= cap && cap < maxCapacity)  // resize (扩容)
                    added = growAndOffer(item, a, t);
                else if (n >= cap || unowned)       // need volatile CAS (CAS 替换)
                    added = QA.compareAndSet(a, i, null, item);
                else {                              // can use release mode (设置值)
                    QA.setRelease(a, i, item); 
                    added = true;
                }
                if (added) {        // 添加成功
                    tail = t + 1;   // 改下标（可循环使用数组）
                    stat = n;
                }
            }
            return startOnOffer(stat);  // 尝试启动，ref: sign_m_221
        }

        /**
         * sign_m_221 尝试在添加后启动消费者任务
         */
        final int startOnOffer(int stat) {
            int c; // start or keep alive if requests exist and not active
            if (((c = ctl) & (REQS | ACTIVE)) == REQS &&
                ((c = getAndBitwiseOrCtl(RUN | ACTIVE)) & (RUN | CLOSED)) == 0)
                tryStart(); // 尝试启动，ref: sign_m_222
            ...
            return stat;
        }

        // sign_m_222 尝试启动消费者任务
        final void tryStart() {
            try {
                Executor e;
                ConsumerTask<T> task = new ConsumerTask<T>(this);
                if ((e = executor) != null)   // skip if disabled on error
                    e.execute(task);
            } ... // catch
        }
```