## 使用示例
- https://github.com/zengxf/small-frame-demo/blob/master/multi-thread/reactive-test/reactor-demo/src/main/java/cn/zxf/reactor_demo/jdk/PubSubTest.java


## JDK 版本
```js
openjdk version "17" 2021-09-14
OpenJDK Runtime Environment (build 17+35-2724)
OpenJDK 64-Bit Server VM (build 17+35-2724, mixed mode, sharing)
```


## 原理
### 关键类
- `java.util.concurrent.SubmissionPublisher`

```java
// 提交式-发布者
public class SubmissionPublisher<T> implements Publisher<T>, AutoCloseable {
    BufferedSubscription<T> clients;    // 客户端（BufferedSubscriptions）链表
    final ReentrantLock lock;           // 锁定以排除多个源
    volatile boolean closed;            // 运行状态，仅在锁内更新
    boolean subscribed; // 在第一次调用订阅时设置 true，以初始化可能的拥有者
    Thread owner;       // 第一个要订阅的调用者线程，如果线程发生更改则为 null
    volatile Throwable closedException; // closeExceptionally 中的异常
    final Executor executor;            // 用于构造 BufferedSubscriptions 的参数
    final BiConsumer<? super Subscriber<? super T>, ? super Throwable> onNextHandler;
    final int maxBufferCapacity;

    // 调用入口 ref: sign_demo_001
    public SubmissionPublisher() {
        this(ASYNC_POOL, Flow.defaultBufferSize(), null);   // ref: sign_cm_002
    }

    // sign_cm_002
    public SubmissionPublisher(
        Executor executor, int maxBufferCapacity,
        BiConsumer<? super Subscriber<? super T>, ? super Throwable> handler
    ) {
        ... // 参数校验
        this.lock = new ReentrantLock();
        this.executor = executor;   // def: ForkJoinPool
        this.onNextHandler = handler;
        this.maxBufferCapacity = roundCapacity(maxBufferCapacity);  // def: 256
    }
}
```

### 订阅
```java
    // 订阅（添加订阅者）。调用入口 ref: sign_demo_010
    public void subscribe(Subscriber<? super T> subscriber) {
        if (subscriber == null) throw new NullPointerException();
        ReentrantLock lock = this.lock;
        int max = maxBufferCapacity;
        // INITIAL_CAPACITY = 32, 默认情况下计算完数组长度为 32
        Object[] array = new Object[max < INITIAL_CAPACITY ? max : INITIAL_CAPACITY]; 
        // 初始化订阅关系，ref: sign_c_110 | sign_cm_110
        BufferedSubscription<T> subscription = new BufferedSubscription<T>(
            subscriber, executor, onNextHandler, array, max
        );
        lock.lock();
        try {
            if (!subscribed) {
                subscribed = true;
                owner = Thread.currentThread();
            }
            for (BufferedSubscription<T> b = clients, pred = null;;) {
                if (b == null) {    // 还没有初始化链
                    Throwable ex;
                    subscription.onSubscribe();
                    if ((ex = closedException) != null)
                        subscription.onError(ex);   // 有异常
                    else if (closed)
                        subscription.onComplete();  // 已关闭
                    else if (pred == null)
                        clients = subscription;     // 初始化链
                    else
                        pred.next = subscription;   // 加入链
                    break;
                }
                BufferedSubscription<T> next = b.next;
                if (b.isClosed()) {   // remove
                    b.next = null;    // detach
                    if (pred == null)
                        clients = next;
                    else
                        pred.next = next;
                }
                else if (subscriber.equals(b.subscriber)) {
                    // 不能重复添加
                    b.onError(new IllegalStateException("Duplicate subscribe"));
                    break;
                }
                else
                    pred = b;   // 方便后面的加入链
                b = next;       // 方便遍历链路
            }
        } finally {
            lock.unlock();
        }
    }
```

- `java.util.concurrent.SubmissionPublisher.BufferedSubscription`
```java
    // sign_c_110 订阅关系
    static final class BufferedSubscription<T> implements Subscription, ForkJoinPool.ManagedBlocker {
        long timeout;                      // Long.MAX_VALUE if untimed wait
        int head;                          // next position to take
        int tail;                          // next position to put
        final int maxCapacity;             // max buffer size
        volatile int ctl;                  // atomic run state flags
        Object[] array;                    // buffer
        final Subscriber<? super T> subscriber;
        final BiConsumer<? super Subscriber<? super T>, ? super Throwable> onNextHandler;
        Executor executor;                 // null on error

        BufferedSubscription<T> next;      // 组装链 

        // sign_cm_110
        BufferedSubscription(
            Subscriber<? super T> subscriber,   // 自定义的订阅者
            Executor executor,      // ForkJoinPool
            BiConsumer<? super Subscriber<? super T>, ? super Throwable> onNextHandler, // null
            Object[] array,         // len: 32
            int maxBufferCapacity   // 256
        ) {
            this.subscriber = subscriber;
            this.executor = executor;
            this.onNextHandler = onNextHandler;
            this.array = array;
            this.maxCapacity = maxBufferCapacity;
        }
    }
```