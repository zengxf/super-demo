## 使用示例
- https://github.com/zengxf/small-frame-demo/blob/master/jdk-demo/simple-demo/src/main/java/test/jdkapi/juc/thread_pool/TestSchedule.java


## JDK 版本
```js
openjdk version "17" 2021-09-14
OpenJDK Runtime Environment (build 17+35-2724)
OpenJDK 64-Bit Server VM (build 17+35-2724, mixed mode, sharing)
```


## 原理
### 类结构
- `java.util.concurrent.ScheduledThreadPoolExecutor`
```java
/*** 调度线程池 */
public class ScheduledThreadPoolExecutor
        extends ThreadPoolExecutor
        implements ScheduledExecutorService 
{
    /*** 构造器 */
    public ScheduledThreadPoolExecutor(int corePoolSize) {
        super(corePoolSize, Integer.MAX_VALUE,
              DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,
              new DelayedWorkQueue()); // 使用内部队列作任务队列 sign_c_001
    }

}
```

- `java.util.concurrent.ScheduledThreadPoolExecutor.DelayedWorkQueue`
```java
    /*** 延迟任务队列 sign_c_001 */
    static class DelayedWorkQueue extends AbstractQueue<Runnable>
        implements BlockingQueue<Runnable> 
    {
        private static final int INITIAL_CAPACITY = 16; // 初始队列大小 16 个
        private RunnableScheduledFuture<?>[] queue =
            new RunnableScheduledFuture<?>[INITIAL_CAPACITY];
    }
```

- `java.util.concurrent.ScheduledThreadPoolExecutor.ScheduledFutureTask`
```java
    /*** 调度任务 sign_c_010 */
    private class ScheduledFutureTask<V>
            extends FutureTask<V> implements RunnableScheduledFuture<V> // 继承 sign_c_011 实现 sign_i_011
    {
        private final long sequenceNumber;  // 序列号(添加时递增设置)
        private volatile long time;         // 触发时间(执行的时间点)，基于纳米
        /**
         * 重复任务的周期，以纳秒为单位。
         * 正值表示固定速率执行。
         * 负值表示固定延迟执行。
         * 值为 0 表示非重复（单次）任务。
         */
        private final long period;

        // 构造器
        ScheduledFutureTask(Runnable r, V result, long triggerTime,
                            long period, long sequenceNumber) {
            super(r, result); // 执行体交给父类(sign_c_011)保存
            this.time = triggerTime;
            this.period = period;
            this.sequenceNumber = sequenceNumber;
        }
    }
```

- `java.util.concurrent.FutureTask`
```java
/*** sign_c_011 */
public class FutureTask<V> implements RunnableFuture<V> {
    private volatile int state;     // 状态
    private Callable<V> callable;   // 封装的任务
    public FutureTask(Runnable runnable, V result) {
        this.callable = Executors.callable(runnable, result);
        this.state = NEW;       // ensure visibility of callable
    }
}
```

- `Future` 相关接口定义
```java
// sign_i_011
// java.util.concurrent.RunnableScheduledFuture
public interface RunnableScheduledFuture<V> extends RunnableFuture<V>, ScheduledFuture<V> {
    /**
     * 判断是不是周期任务
     */
    boolean isPeriodic();
}

// java.util.concurrent.ScheduledFuture
public interface ScheduledFuture<V> extends Delayed, Future<V> {
}

// java.util.concurrent.Delayed
public interface Delayed extends Comparable<Delayed> {
    /**
     * 获取延时时间，
     * Comparable 用于排序，延时小的排前面。
     */
    long getDelay(TimeUnit unit);
}
```

### 调用链
- `java.util.concurrent.ScheduledThreadPoolExecutor`
```java
    /*** 创建调度任务 */
    public ScheduledFuture<?> scheduleAtFixedRate(Runnable command,
                                                  long initialDelay,
                                                  long period,
                                                  TimeUnit unit) {
        ... // 省略校验
        ScheduledFutureTask<Void> sft = // 创建调度任务 sign_c_010 
            new ScheduledFutureTask<Void>(command,
                                          null,
                                          triggerTime(initialDelay, unit),
                                          unit.toNanos(period),
                                          sequencer.getAndIncrement());
        RunnableScheduledFuture<Void> t = decorateTask(command, sft);
        sft.outerTask = t;
        delayedExecute(t);
        return t;
    }

    // 延迟执行
    private void delayedExecute(RunnableScheduledFuture<?> task) {
        if (isShutdown())
            reject(task);
        else {
            super.getQueue().add(task); // 添加到队列
            if (!canRunInCurrentRunState(task) && remove(task))
                task.cancel(false);
            else
                ensurePrestart();       // 启动任务执行者线程
        }
    }
```