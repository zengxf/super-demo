## 使用示例
- https://github.com/zengxf/small-frame-demo/blob/master/jdk-demo/simple-demo/src/main/java/test/new_features/jdk1_8/stream/TestStream.java
- 基础方法使用测试：`test_base()`


## JDK 版本
```js
openjdk version "17" 2021-09-14
OpenJDK Runtime Environment (build 17+35-2724)
OpenJDK 64-Bit Server VM (build 17+35-2724, mixed mode, sharing)
```


## 原理
### 数据结构
```js
// 刚开始组装的是双向链表，
//     上游(previousStage) <-> 下游(nextStage)
//     结构如下：
Head(List) <-> filter <-> map <-> skip <-> peek <-> sorted <-> limit <-> forEach

// 调用终止符 forEach() 方法后，组装的 Sink 是单向链表，
//     当前 -> 下游(downstream)
//     结构如下：
Head(List) -> filter -> map -> skip -> peek -> sorted -> limit -> forEach
```

### 类结构
- `java.util.stream.ReferencePipeline.Head`
```java
    /** 流水线-头(首节点、最上游的数据源) sign_c_010 */
    static class Head<E_IN, E_OUT> extends ReferencePipeline<E_IN, E_OUT> { // 继承 sign_c_020
        Head(Spliterator<?> source, int sourceFlags, boolean parallel) {
            super(source, sourceFlags, parallel); // sign_cm_020
        }
    }
```

- `java.util.stream.ReferencePipeline.StatelessOp`
```java
    /** 无状态操作节点 sign_c_011 */
    abstract static class StatelessOp<E_IN, E_OUT>
            extends ReferencePipeline<E_IN, E_OUT> 
    {
        // 构造器 (用于设置上游) sign_cm_010
        StatelessOp(AbstractPipeline<?, E_IN, ?> upstream, StreamShape inputShape, int opFlags) {
            super(upstream, opFlags); // sign_cm_021
            assert upstream.getOutputShape() == inputShape;
        }
    }
```

- `java.util.stream.ReferencePipeline`
```java
/** 引用类型流水线 sign_c_020 */
abstract class ReferencePipeline<P_IN, P_OUT>
        extends AbstractPipeline<P_IN, P_OUT, Stream<P_OUT>> // 继承 sign_c_030
        implements Stream<P_OUT>  
{
    // 构造器 (专用于设置源) sign_cm_020
    ReferencePipeline(Spliterator<?> source, int sourceFlags, boolean parallel) {
        super(source, sourceFlags, parallel); // sign_cm_030
    }

    // 构造器 (专用于设置上游) sign_cm_021
    ReferencePipeline(AbstractPipeline<?, P_IN, ?> upstream, int opFlags) {
        super(upstream, opFlags); // sign_cm_031
    }

    // 组装 Sink。 sign_am_010
    abstract Sink<E_IN> opWrapSink(int flags, Sink<E_OUT> sink);
}
```

- `java.util.stream.AbstractPipeline`
```java
/** 基础流水线 (链表节点) sign_c_030 */
abstract class AbstractPipeline<E_IN, E_OUT, S extends BaseStream<E_OUT, S>>
        extends PipelineHelper<E_OUT> implements BaseStream<E_OUT, S> 
{
    private final AbstractPipeline sourceStage;     // 数据源节点
    private final AbstractPipeline previousStage;   // 上游节点 (与 nextStage 组成双向链表)
    private AbstractPipeline nextStage;
    private int depth;          // 深度 (相当于第几个节点)
    private Spliterator<?> sourceSpliterator;       // 数据源
    private boolean parallel;   // 并行标识

    // 构造器 (专用于设置源) sign_cm_030
    AbstractPipeline(Supplier<? extends Spliterator<?>> source, int sourceFlags, boolean parallel) {
        this.previousStage = null;      // 上游节点为空
        this.sourceSupplier = source;   // 保存源数据
        this.sourceStage = this;        // 设置源节点为自己
        this.sourceOrOpFlags = sourceFlags & StreamOpFlag.STREAM_MASK;
        this.combinedFlags = (~(sourceOrOpFlags << 1)) & StreamOpFlag.INITIAL_OPS_VALUE;
        this.depth = 0;                 // 深度为 0
        this.parallel = parallel;
    }

    // 构造器 (专用于设置上游) sign_cm_031
    AbstractPipeline(AbstractPipeline<?, E_IN, ?> previousStage, int opFlags) {
        if (previousStage.linkedOrConsumed)
            throw new IllegalStateException(MSG_STREAM_LINKED); // 防重复添加
        previousStage.linkedOrConsumed = true;  // 设置已被添加
        previousStage.nextStage = this;         // 将上游节点的下游设置为自己

        this.previousStage = previousStage;     // 设置上游节点
        this.sourceOrOpFlags = opFlags & StreamOpFlag.OP_MASK;
        this.combinedFlags = StreamOpFlag.combineOpFlags(opFlags, previousStage.combinedFlags);
        this.sourceStage = previousStage.sourceStage; // 从上游查找源节点 (相当于是头节点)
        if (opIsStateful())
            sourceStage.sourceAnyStateful = true;
        this.depth = previousStage.depth + 1;   // 深度(递增)加 1
    }
}
```

- `java.util.stream.Sink.ChainedReference`
```java
    
    abstract static class ChainedReference<T, E_OUT> implements Sink<T> {
        protected final Sink<? super E_OUT> downstream;

        public ChainedReference(Sink<? super E_OUT> downstream) {
            this.downstream = Objects.requireNonNull(downstream);
        }
    }
```

### 调用链
#### xxList.stream()
- `java.util.Collection`
```java
    default Stream<E> stream() {
        return StreamSupport.stream(spliterator(), false); // 创建流 sign_m_010
    }

    @Override
    default Spliterator<E> spliterator() {
        // 将当前 list 作为数据源
        return Spliterators.spliterator(this, 0);
    }
```

- `java.util.stream.StreamSupport`
```java
    // 创建流 sign_m_010
    public static <T> Stream<T> stream(Spliterator<T> spliterator, boolean parallel) {
        Objects.requireNonNull(spliterator);
        return new ReferencePipeline.Head<>(spliterator, // 创建头节点 sign_c_010
                                            StreamOpFlag.fromCharacteristics(spliterator),
                                            parallel);
    }
```

#### stream.filter()
- `java.util.stream.ReferencePipeline`
```java
    // 过滤
    @Override
    public final Stream<P_OUT> filter(Predicate<? super P_OUT> predicate) {
        Objects.requireNonNull(predicate);
        /**
         * 创建一个匿名无状态操作节点 sign_c_011
         * 
         * 将自己作为新节点的上游，同时将新节点作为自己的下游 sign_cm_010 sign_cm_031
         */
        return new StatelessOp<P_OUT, P_OUT>(this, StreamShape.REFERENCE, StreamOpFlag.NOT_SIZED) {
            @Override // 只重写 opWrapSink 方法 sign_am_010
            Sink<P_OUT> opWrapSink(int flags, Sink<P_OUT> sink) {
                // 创建(引用类型) Sink 链节点
                return new Sink.ChainedReference<P_OUT, P_OUT>(sink) {
                    @Override
                    public void begin(long size) {
                        downstream.begin(-1);
                    }

                    @Override
                    public void accept(P_OUT u) {
                        if (predicate.test(u))      // 过滤判断
                            downstream.accept(u);   // 满足条件的才给下游消费
                    }
                };
            }
        };
    }
```