# RocketMQ-命名服务处理请求


---
## 请求处理
- `org.apache.rocketmq.remoting.netty.NettyRemotingServer.NettyServerHandler`
  - 此处理器添加的方法参考： [命名服务启动-启动控制器 sign_m_222](命名服务启动.md#启动控制器)
  - 端口映射服务参考： [命名服务启动-启动控制器 sign_cb_220](命名服务启动.md#启动控制器)
```java
    // sign_c_110  服务请求处理器 
    @ChannelHandler.Sharable    // 通过父类模板，只处理 RemotingCommand 实例请求。原理是获取具体泛型类，再进行 clazz.isInstance() 判断
    public class NettyServerHandler extends SimpleChannelInboundHandler<RemotingCommand> {

        // sign_m_110  处理接收信息
        @Override
        protected void channelRead0(ChannelHandlerContext ctx, RemotingCommand msg) {
            int localPort = RemotingHelper.parseSocketAddressPort(ctx.channel().localAddress());
            /*
                端口为 9876 表示为服务方，返回 NettyRemotingServer 实例，
                    端口映射服务参考： [命名服务启动-启动控制器 sign_cb_220]；
            */
            NettyRemotingAbstract remotingAbstract = NettyRemotingServer.this.remotingServerTable.get(localPort);
            if (localPort != -1 && remotingAbstract != null) {  // 进入此逻辑
                remotingAbstract.processMessageReceived(ctx, msg);  // 处理消息接收，ref: sign_m_130
                return;
            }

            // 相关远程服务器已关闭，因此将关闭此连接的通道
            RemotingHelper.closeChannel(ctx.channel());
        }
    }
```

- `org.apache.rocketmq.remoting.netty.NettyRemotingServer`
```java
// sign_c_120
public class NettyRemotingServer extends NettyRemotingAbstract implements RemotingServer {
}
```

- `org.apache.rocketmq.remoting.netty.NettyRemotingAbstract`
```java
// sign_c_130
public abstract class NettyRemotingAbstract {

    // sign_m_130  处理消息接收
    public void processMessageReceived(ChannelHandlerContext ctx, RemotingCommand msg) {
            switch (msg.getType()) {
                case REQUEST_COMMAND:
                    processRequestCommand(ctx, msg);    // 处理请求命令，ref: sign_m_131
                    break;
                case RESPONSE_COMMAND:
                    processResponseCommand(ctx, msg);
                    break;
            }
    }

    // sign_m_131  处理请求命令
    public void processRequestCommand(final ChannelHandlerContext ctx, final RemotingCommand cmd) {
        final Pair<NettyRequestProcessor, ExecutorService> matched = this.processorTable.get(cmd.getCode()); // 只配置了 105

        // code 为 103, pair 对象类型为 < DefaultRequestProcessor : FutureTaskExtThreadPoolExecutor >
        final Pair<NettyRequestProcessor, ExecutorService> pair = null == matched ? this.defaultRequestProcessorPair : matched;
        ...

        ... // pair 空校验处理

        Runnable run = buildProcessRequestHandler(ctx, cmd, pair, ...); // 构建异步执行体，ref: sign_m_132

        ... // 停机判断
        ... // 拒绝(限流)判断

        try {
            final RequestTask requestTask = new RequestTask(run, ctx.channel(), cmd);   // 封装成任务
            pair.getObject2().submit(requestTask);  // (提交到线程池) 异步执行
        } ... // catch
    }

    // sign_m_132  构建异步请求执行体
    private Runnable buildProcessRequestHandler(
        ChannelHandlerContext ctx, RemotingCommand cmd,
        Pair<NettyRequestProcessor, ExecutorService> pair, ...
    ) {
        return () -> {
            Exception exception = null;
            RemotingCommand response;

            try {
                ...
                ... // 钩子前处理

                if (exception == null) {
                    // pair.getObject1() 一般为 DefaultRequestProcessor 实例
                    response = pair.getObject1().processRequest(ctx, cmd);  // 处理请求
                } else {
                    ...
                }

                ... // 钩子后处理
                ... // 异常处理

                writeResponse(ctx.channel(), cmd, response);    // 回写处理结果 (响应), ref: sign_m_133
            } ... // catch
        };
    }

    // sign_m_133  进行响应
    public static void writeResponse(Channel channel, RemotingCommand request, RemotingCommand response) {
        writeResponse(channel, request, response, null);    // ref: sign_m_134
    }

    // sign_m_134  进行响应
    public static void writeResponse(
        Channel channel, RemotingCommand request, RemotingCommand response,
        Consumer<Future<?>> callback
    ) {
        ...

        response.setOpaque(request.getOpaque());
        response.markResponseType();
        try {
            // 响应 (使用 Netty 信道回写结果)
            channel.writeAndFlush(response).addListener((ChannelFutureListener) future -> {
                ... // 打印日志
                ... // 记录处理
                ... // 回调处理
            });
        } ... // catch
    }
}
```