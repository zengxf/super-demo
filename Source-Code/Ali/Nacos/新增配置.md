## 入口
- WebUI: http://127.0.0.1:8848/nacos
- 操作: `配置列表 -> 创建配置`
- REST-API: `/v1/cs/configs`
  - 修改配置也是走此接口


## 原理
- `com.alibaba.nacos.config.server.controller.ConfigController`
```java
/** 配置 Web 控制器 */
@RestController
@RequestMapping(Constants.CONFIG_CONTROLLER_PATH)
public class ConfigController {

    // path: /v1/cs/configs
    @PostMapping // 新增或修改
    @TpsControl(pointName = "ConfigPublish")
    @Secured(action = ActionTypes.WRITE, signType = SignType.CONFIG)
    public Boolean publishConfig(HttpServletRequest request, HttpServletResponse response,
            @RequestParam ... // 省略参数
    ) throws NacosException {
        
        // 根据需要加密
        Pair<String, String> pair = EncryptionHandler.encryptHandler(dataId, content);
        content = pair.getSecond();
        
        ... // 省略参数校验
    
        ConfigForm configForm = new ConfigForm();
        ... // 省略使用参数来组装 configForm
    
        ConfigRequestInfo configRequestInfo = new ConfigRequestInfo();
        ... // 省略对 configRequestInfo 的客户端 IP 等的填充
    
        String encryptedDataKey = pair.getFirst();  // 加密 key
       
        // 创建或修改配置，ref: sign_m_110 
        return configOperationService.publishConfig(configForm, configRequestInfo, encryptedDataKey);
    }
}
```

- `com.alibaba.nacos.config.server.service.ConfigOperationService`
```java
/** 配置操作服务类 */
@Service
public class ConfigOperationService {

    // sign_m_110 创建或修改配置
    public Boolean publishConfig(ConfigForm configForm, ConfigRequestInfo configRequestInfo, String encryptedDataKey)
            throws NacosException 
    {
        Map<String, Object> configAdvanceInfo = getConfigAdvanceInfo(configForm);   // 转 Map
        ParamUtils.checkParam(configAdvanceInfo);   // 校验
        
        ... // 校验是否为聚合 ID
        
        final Timestamp time = TimeUtils.getCurrentTime();
        ConfigInfo configInfo = ... // 从 configForm 创建
        
        configInfo.setType(configForm.getType());
        configInfo.setEncryptedDataKey(encryptedDataKey);
        
        if (StringUtils.isBlank(configRequestInfo.getBetaIps())) {
            if (StringUtils.isBlank(configForm.getTag())) {
                // 持久化到 DB
                configInfoPersistService.insertOrUpdate(configRequestInfo.getSrcIp(), configForm.getSrcUser(),
                        configInfo, time, configAdvanceInfo, false);
                // 发布更新事件，ref: sign_m_210
                ConfigChangePublisher.notifyConfigChange(
                        new ConfigDataChangeEvent(false, configForm.getDataId(), configForm.getGroup(),
                                configForm.getNamespaceId(), time.getTime()));
            } else {
                ... // tag 不为空的处理
            }
        } else {
            ... // beta 发布
        }
        ... // log
        
        return true;
    }
}
```

### 发布更新事件
- `com.alibaba.nacos.config.server.service.ConfigChangePublisher`
```java
/** 配置更改发布器 */
public class ConfigChangePublisher {
    // sign_m_210 发布更新事件
    public static void notifyConfigChange(ConfigDataChangeEvent event) {
        if (PropertyUtil.isEmbeddedStorage() && !EnvUtil.getStandaloneMode()) {
            return;
        }
        NotifyCenter.publishEvent(event);   // 发布事件 sign_m_310
    }
}
```

- `com.alibaba.nacos.common.notify.NotifyCenter`
```java
/** 统一事件通知中心 */
public class NotifyCenter {
    
    static {
        ...

        // 默认发布器工厂
        DEFAULT_PUBLISHER_FACTORY = (cls, buffer) -> {
            try {
                EventPublisher publisher = clazz.newInstance(); // 直接用类反射创建一个实例
                publisher.init(cls, buffer);                    // 初始化发布器，ref: sign_m_410
                return publisher;
            } ... // catch
        };
        
        ...
    }

    // sign_m_310 发布事件
    public static boolean publishEvent(final Event event) {
        try {
            return publishEvent(event.getClass(), event);   // sign_m_311
        } ... // catch
    }

    // sign_m_311
    private static boolean publishEvent(Class<? extends Event> eventType, Event event) {
        ... // Slow 事件，DefaultSharePublisher 直接发送处理
        
        final String topic = ClassUtils.getCanonicalName(eventType);    // 用类名作主题
        EventPublisher publisher = INSTANCE.publisherMap.get(topic);    // 查找发布器
        if (publisher != null) {
            /**
             * 一般默认实现是 DefaultPublisher 类 (配置更改事件的发布器也是它)，
             * 发布事件，ref: sign_m_420
             */
            return publisher.publish(event);
        }

        ... // 插件的事件，不做处理
        ... // 没有发布器，不做处理
    }
}
```

- `com.alibaba.nacos.common.notify.DefaultPublisher`
```java
/** 默认事件发布器 */
public class DefaultPublisher extends Thread implements EventPublisher {
    
    private Class<? extends Event> eventType;   // 事件类型
    protected final ConcurrentHashSet<Subscriber> subscribers = new ConcurrentHashSet<>();  // 订阅者
    private BlockingQueue<Event> queue;         // 缓冲队列

    // sign_m_410 初始化
    @Override
    public void init(Class<? extends Event> type, int bufferSize) {
        setDaemon(true);    // 设置为守护线程
        setName("nacos.publisher-" + type.getName());
        this.eventType = type;
        this.queueMaxSize = bufferSize;
        this.queue = new ArrayBlockingQueue<>(bufferSize);
        start();    // 启动 (自己) 线程，ref: sign_m_411
    }
    
    // sign_m_411
    @Override
    public synchronized void start() {
        if (!initialized) {
            super.start();      // 调用父类启动线程
            if (queueMaxSize == -1) {
                queueMaxSize = ringBufferSize;  // def: 16384 (16k)
            }
            initialized = true;
        }
    }

    // sign_m_420 发布事件
    @Override
    public boolean publish(Event event) {
        checkIsStart(); // 校验是否已启动
        boolean success = this.queue.offer(event);  // 先添加到队列
        if (!success) {
            ... // log
            receiveEvent(event);    // 添加不了，则直接发送事件给所有订阅者，ref: sign_m_433
            return true;
        }
        return true;
    }

    // 线程执行体
    @Override
    public void run() {
        openEventHandler(); // sign_m_431
    }

    // sign_m_431
    void openEventHandler() {
        try {
            ... // 没订阅者，循环等待 60 次，每次 1 秒。以确保消息不丢失

            while (!shutdown) {
                final Event event = queue.take();
                receiveEvent(event);    // sign_m_433
                UPDATER.compareAndSet(this, lastEventSequence, Math.max(lastEventSequence, event.sequence()));
            }
        } ... // catch
    }

    // sign_m_433
    void receiveEvent(Event event) {
        final long currentEventSequence = event.sequence();
        
        ... // 无订阅者，返回
        
        // Notification single event listener
        for (Subscriber subscriber : subscribers) {
            ... // 订阅者是否匹配处理
            ... // 事件过期不处理
            
            notifySubscriber(subscriber, event);    // sign_m_435
        }
    }

    // sign_m_435
    @Override
    public void notifySubscriber(final Subscriber subscriber, final Event event) {
        final Runnable job = () -> subscriber.onEvent(event);   // 封装
        final Executor executor = subscriber.executor();
        
        if (executor != null) {
            executor.execute(job);  // 订阅者有执行器，交给其处理
        } else {
            try {
                job.run();          // 没有执行器，直接执行
            } ... // catch 
        }
    }
}
```