# Dubbo-客户端调用


---
## 单元测试
- `org.apache.dubbo.rpc.protocol.dubbo.DubboInvokerAvailableTest`
  - 代理工厂参考：[服务发现-代理工厂 sign_m_410 | sign_m_430](./服务发现.md#代理工厂)
```java
class DubboInvokerAvailableTest {

    @Test
    public void testPreferSerialization() throws Exception {
        int port = 31088;
        URL url = URL.valueOf(
                    "dubbo://127.0.0.1:" + port
                        + "/org.apache.dubbo.rpc.protocol.dubbo.IDemoService?" 
                        + "lazy=true&connections=1&timeout=10000&serialization=fastjson&prefer_serialization=fastjson2,hessian2"
                );
        ProtocolUtils.export(new DemoServiceImpl(), IDemoService.class, url);

        Invoker<?> invoker = protocol.refer(IDemoService.class, url);
        ExchangeClient exchangeClient = getClients((DubboInvoker<?>) invoker)[0];
        
        // invoke method --> init client
        IDemoService service = (IDemoService) proxy.getProxy(invoker);  // 参考：[服务发现-代理工厂 sign_m_410 | sign_m_430]
        String actual = service.get();
    }
}
```


---
## 代理调用处理器
- `org.apache.dubbo.rpc.proxy.InvokerInvocationHandler`
```java
// sign_c_110
public class InvokerInvocationHandler implements InvocationHandler {

    // sign_m_110  调用处理
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        ... // Object 类的基础方法处理

        RpcInvocation rpcInvocation = new RpcInvocation(...);
        ...

        // invoker 一般为链式对象，底层为 DubboInvoker 实例
        return InvocationUtil.invoke(invoker, rpcInvocation);   // ref: sign_m_120
    }
}
```

- `org.apache.dubbo.rpc.proxy.InvocationUtil`
```java
// sign_c_120
public class InvocationUtil {

    // sign_m_120  调用处理
    public static Object invoke(Invoker<?> invoker, RpcInvocation rpcInvocation) throws Throwable {
        try {
            URL url = invoker.getUrl();
            String serviceKey = url.getServiceKey();
            rpcInvocation.setTargetServiceUniqueName(serviceKey);

            // 将 url 设置到上下文中，invoker.getUrl() 会返回
            RpcServiceContext.getServiceContext().setConsumerUrl(url);

            if (ProfilerSwitch.isEnableSimpleProfiler()) {
                ProfilerEntry bizProfiler = ... Profiler.start(...);
                rpcInvocation.put(Profiler.PROFILER_KEY, bizProfiler);
                try {
                    return invoker.invoke(rpcInvocation)    // 调用器链式处理，最终会调用到 DubboInvoker，ref: sign_c_130 | sign_m_140 | sign_m_130
                        .recreate();
                } 
                finally { ... }
            }
            return invoker.invoke(rpcInvocation).recreate();
        } 
        finally { ... }
    }
}
```

- `org.apache.dubbo.rpc.protocol.dubbo.DubboInvoker`
```java
// sign_c_130
public class DubboInvoker<T> extends AbstractInvoker<T> {

    // sign_m_130  处理调用并返回结果
    @Override
    protected Result doInvoke(final Invocation invocation) throws Throwable {
        RpcInvocation inv = (RpcInvocation) invocation;
        ...

        List<? extends ExchangeClient> exchangeClients = clientsProvider.getClients();
        ExchangeClient currentClient = ... exchangeClients.get(...round);   // 轮循使用客户端。实例为: LazyConnectExchangeClient, ref: sign_c_150
        try {
            boolean isOneway = RpcUtils.isOneway(getUrl(), invocation);
            int timeout = RpcUtils.calculateTimeout(getUrl(), ..., DEFAULT_TIMEOUT);
            ...

            Request request = new Request();
            request.setData(inv);
            ... // 填充 request

            if (isOneway) { 
                ...
            } else {
                ExecutorService executor = getCallbackExecutor(getUrl(), inv);
                CompletableFuture<AppResponse> appResponseFuture = currentClient.request(request, timeout, executor)    // 客户端请求，ref: sign_m_150
                        .thenApply(AppResponse.class::cast);

                ... // 将 appResponseFuture 记录到上下文

                AsyncRpcResult result = new AsyncRpcResult(appResponseFuture, inv);
                result.setExecutor(executor);
                return result;
            }
        }
        ... // catch
    }
}
```

- `org.apache.dubbo.rpc.protocol.AbstractInvoker`
```java
// sign_c_140
public abstract class AbstractInvoker<T> implements Invoker<T> {

    // sign_m_140  处理调用
    @Override
    public Result invoke(Invocation inv) throws RpcException {
        ... // log

        RpcInvocation invocation = (RpcInvocation) inv;
        ...

        // RPC 调用并返回异步结果
        AsyncRpcResult asyncResult = doInvokeAndReturn(invocation); // ref: sign_m_141

        ... // 如果同步，则等待 RPC 结果

        return asyncResult;
    }

    // sign_m_141  调用并返回结果
    private AsyncRpcResult doInvokeAndReturn(RpcInvocation invocation) {
        AsyncRpcResult asyncResult;
        try {
            asyncResult = (AsyncRpcResult) doInvoke(invocation);    // 调用子类具体实现。ref: sign_m_130
        } 
        ... // catch

        ... // 结果上下文处理

        return asyncResult;
    }
}
```

- `org.apache.dubbo.rpc.protocol.dubbo.LazyConnectExchangeClient`
```java
// sign_c_150
final class LazyConnectExchangeClient implements ExchangeClient {

    // sign_m_150  进行请求
    @Override
    public CompletableFuture<Object> request(
        Object request, int timeout, ExecutorService executor
    ) throws RemotingException {
        ...
        checkClient();  // 初始化客户端并校验，ref: sign_m_151
        return client.request(request, timeout, executor);  // 发送 RPC 请求
    }
    
    // sign_m_151  校验和初始化客户端
    private void checkClient() {
        try {
            initClient();   // ref: sign_m_152
        } 
        ... // catch

        ... // 校验
    }

    // sign_m_152  初始化客户端
    private void initClient() throws RemotingException {
            ... // DCL
            this.client = Exchangers.connect(url, requestHandler);  // ref: sign_sm_210
    }
}
```


---
## 创建客户端
- `org.apache.dubbo.remoting.exchange.Exchangers`
```java
// sign_c_210
public class Exchangers {

    // sign_sm_210
    public static ExchangeClient connect(URL url, ExchangeHandler handler) throws RemotingException {
        ... // 校验
        return getExchanger(url)        // 返回 HeaderExchanger 实例，ref: sign_sm_211
            .connect(url, handler);     // ref: sign_m_220
    }
    
    // sign_sm_211
    public static Exchanger getExchanger(URL url) {
        String type = url.getParameter(Constants.EXCHANGER_KEY, Constants.DEFAULT_EXCHANGER);   // 值为："header"
        // 返回 HeaderExchanger 实例
        return url.getOrDefaultFrameworkModel()
                .getExtensionLoader(Exchanger.class)
                .getExtension(type);
    }
}
```

- `org.apache.dubbo.remoting.exchange.support.header.HeaderExchanger`
```java
// sign_c_220
public class HeaderExchanger implements Exchanger {

    // sign_m_220
    @Override
    public ExchangeClient connect(URL url, ExchangeHandler handler) throws RemotingException {
        return new HeaderExchangeClient(
                Transporters.connect(url, new DecodeHandler(new HeaderExchangeHandler(handler)))    // ref: sign_sm_230
                , true
            );
    }
}
```

- `org.apache.dubbo.remoting.Transporters`
  - 适配器参考：[$Adaptive-类-其他生成的类参考 sign_m_270](./$Adaptive-类.md#其他生成的类参考)
```java
// sign_c_230
public class Transporters {

    // sign_sm_230
    public static Client connect(URL url, ChannelHandler... handlers) throws RemotingException {
        ...
        ChannelHandler handler = ... handlers[0];
        ...

        /*
            返回 Transporter$Adaptive 实例；

            相当于下面的代码：
                ScopeModelUtil.getOrDefault(url.getScopeModel(), Transporter.class).getExtensionLoader(Transporter.class).getExtension("netty")
                    .connect(url, handler)
            
            参考：[$Adaptive-类-其他生成的类参考 sign_m_270]
                extension 底层相当于是 netty4.NettyTransporter 实例，ref: sign_c_240

            创建的客户端对象为 netty4.NettyClient 实例，ref: sign_c_250
         */
        return getTransporter(url)  // ref: sign_sm_231
            .connect(url, handler); // ref: sign_m_240
    }

    // sign_sm_231
    public static Transporter getTransporter(URL url) {
        // 返回 Transporter$Adaptive 实例
        return url.getOrDefaultFrameworkModel()
                .getExtensionLoader(Transporter.class)
                .getAdaptiveExtension();
    }
}
```

- `org.apache.dubbo.remoting.transport.netty4.NettyTransporter`
```java
// sign_c_240
public class NettyTransporter implements Transporter {

    // sign_m_240  创建 netty4 客户端
    @Override
    public Client connect(URL url, ChannelHandler handler) throws RemotingException {
        return new NettyClient(url, handler);   // ref: sign_cm_250
    }
}
```

- `org.apache.dubbo.remoting.transport.netty4.NettyClient`
```java
// sign_c_250
public class NettyClient extends AbstractClient {
    private Bootstrap bootstrap;

    // sign_cm_250
    public NettyClient(final URL url, final ChannelHandler handler) throws RemotingException {
        super(url, wrapChannelHandler(url, handler));   // 调用父类，进行初始化连接，ref: sign_cm_260
    }


    // -----------------------

    // sign_m_250  创建并初始化引导
    @Override
    protected void doOpen() throws Throwable {
        final NettyClientHandler nettyClientHandler = new NettyClientHandler(getUrl(), this);
        bootstrap = new Bootstrap();
        initBootstrap(nettyClientHandler);  // ref: sign_m_251
    }

    // sign_m_251  初始化引导
    protected void initBootstrap(NettyClientHandler nettyClientHandler) {
        bootstrap
                .group(EVENT_LOOP_GROUP.get())
                .option(ChannelOption.SO_KEEPALIVE, true)
                .option(ChannelOption.TCP_NODELAY, true)
                .option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)
                .channel(shouldEpoll() ? EpollSocketChannel.class : NioSocketChannel.class);
        ...

        bootstrap.handler(new ChannelInitializer<SocketChannel>() {
            @Override
            protected void initChannel(SocketChannel ch) throws Exception {
                ...

                NettyCodecAdapter adapter = new NettyCodecAdapter(getCodec(), getUrl(), NettyClient.this);
                ch.pipeline()
                        .addLast("decoder", adapter.getDecoder())
                        .addLast("encoder", adapter.getEncoder())
                        .addLast("client-idle-handler", new IdleStateHandler(...))
                        .addLast("handler", nettyClientHandler);

                ... // TCP 代理设置
            }
        });
    }


    // -----------------------
    
    // sign_m_252  进行连接
    @Override
    protected void doConnect() throws Throwable {
        try {
            InetSocketAddress connectAddress;
            ... // IPv6 处理

            connectAddress = new InetSocketAddress(...(getUrl().getHost()), getUrl().getPort());
            doConnect(connectAddress);  // 连接服务，ref: sign_m_253
        } 
        ... // finally
    }

    // sign_m_253  连接服务
    private void doConnect(InetSocketAddress serverAddress) throws RemotingException {
        ChannelFuture future = bootstrap.connect(serverAddress);    // 连接服务
        try {
            boolean ret = future.awaitUninterruptibly(getConnectTimeout(), MILLISECONDS);

            if (ret && future.isSuccess()) {
                Channel newChannel = future.channel();
                ... // 旧理旧的

                NettyClient.this.channel = newChannel;  // 记录新的连接
            }
            ... // 不成功，抛出异常
        } 
        ... // finally
    }
}
```

- `org.apache.dubbo.remoting.transport.AbstractClient`
```java
// sign_c_260
public abstract class AbstractClient extends AbstractEndpoint implements Client {

    // sign_cm_260
    public AbstractClient(URL url, ChannelHandler handler) throws RemotingException {
        super(url, handler);

        needReconnect = url.getParameter(Constants.SEND_RECONNECT_KEY, true);
        initExecutor(url);  // 初始化线程池

        try {
            doOpen();       // 创建并初始化引导，ref: sign_m_250
        } 
        ... // catch 

        try {
            connect();      // 连接，ref: sign_m_260

            ... // log
        } 
        ... // catch 
    }

    // sign_m_260
    protected void connect() throws RemotingException {
        connectLock.lock();
        try {
            if (isConnected()) {
                return;
            }
            ... // log

            doConnect();    // 进行连接，ref: sign_m_252

            ... // log 和校验
        } 
        ... //  catch
        finally {
            connectLock.unlock();
        }
    }
}
```