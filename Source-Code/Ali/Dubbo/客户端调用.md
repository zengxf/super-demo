# Dubbo-客户端调用


---
## 单元测试
- `org.apache.dubbo.rpc.protocol.dubbo.DubboInvokerAvailableTest`
  - 代理工厂参考：[服务发现-代理工厂 sign_m_410 | sign_m_430](./服务发现.md#代理工厂)
```java
class DubboInvokerAvailableTest {

    @Test
    public void testPreferSerialization() throws Exception {
        int port = 31088;
        URL url = URL.valueOf(
                    "dubbo://127.0.0.1:" + port
                        + "/org.apache.dubbo.rpc.protocol.dubbo.IDemoService?" 
                        + "lazy=true&connections=1&timeout=10000&serialization=fastjson&prefer_serialization=fastjson2,hessian2"
                );
        ProtocolUtils.export(new DemoServiceImpl(), IDemoService.class, url);

        Invoker<?> invoker = protocol.refer(IDemoService.class, url);
        ExchangeClient exchangeClient = getClients((DubboInvoker<?>) invoker)[0];
        
        // invoke method --> init client
        IDemoService service = (IDemoService) proxy.getProxy(invoker);  // 参考：[服务发现-代理工厂 sign_m_410 | sign_m_430]
        String actual = service.get();
    }
}
```


---
## 代理调用处理器
- `org.apache.dubbo.rpc.proxy.InvokerInvocationHandler`
```java
// sign_c_110
public class InvokerInvocationHandler implements InvocationHandler {

    // sign_m_110  调用处理
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        ... // Object 类的基础方法处理

        RpcInvocation rpcInvocation = new RpcInvocation(...);
        ...

        // invoker 一般为链式对象，底层为 DubboInvoker 实例
        return InvocationUtil.invoke(invoker, rpcInvocation);   // ref: sign_m_120
    }
}
```

- `org.apache.dubbo.rpc.proxy.InvocationUtil`
```java
// sign_c_120
public class InvocationUtil {

    // sign_m_120  调用处理
    public static Object invoke(Invoker<?> invoker, RpcInvocation rpcInvocation) throws Throwable {
        try {
            URL url = invoker.getUrl();
            String serviceKey = url.getServiceKey();
            rpcInvocation.setTargetServiceUniqueName(serviceKey);

            // 将 url 设置到上下文中，invoker.getUrl() 会返回
            RpcServiceContext.getServiceContext().setConsumerUrl(url);

            if (ProfilerSwitch.isEnableSimpleProfiler()) {
                ProfilerEntry bizProfiler = ... Profiler.start(...);
                rpcInvocation.put(Profiler.PROFILER_KEY, bizProfiler);
                try {
                    return invoker.invoke(rpcInvocation)    // 调用器链式处理，最终会调用到 DubboInvoker，ref: sign_c_130 | sign_m_140 | sign_m_130
                        .recreate();
                } 
                finally { ... }
            }
            return invoker.invoke(rpcInvocation).recreate();
        } 
        finally { ... }
    }
}
```

- `org.apache.dubbo.rpc.protocol.dubbo.DubboInvoker`
```java
// sign_c_130
public class DubboInvoker<T> extends AbstractInvoker<T> {

    // sign_m_130  处理调用并返回结果
    @Override
    protected Result doInvoke(final Invocation invocation) throws Throwable {
        RpcInvocation inv = (RpcInvocation) invocation;
        ...

        List<? extends ExchangeClient> exchangeClients = clientsProvider.getClients();
        ExchangeClient currentClient = ... exchangeClients.get(...round);   // 轮循使用客户端。实例为: LazyConnectExchangeClient, ref: sign_c_150
        try {
            boolean isOneway = RpcUtils.isOneway(getUrl(), invocation);
            int timeout = RpcUtils.calculateTimeout(getUrl(), ..., DEFAULT_TIMEOUT);
            ...

            Request request = new Request();
            request.setData(inv);
            ... // 填充 request

            if (isOneway) { 
                ...
            } else {
                ExecutorService executor = getCallbackExecutor(getUrl(), inv);
                CompletableFuture<AppResponse> appResponseFuture = currentClient.request(request, timeout, executor)    // 客户端请求，ref: sign_m_150
                        .thenApply(AppResponse.class::cast);

                ... // 将 appResponseFuture 记录到上下文

                AsyncRpcResult result = new AsyncRpcResult(appResponseFuture, inv);
                result.setExecutor(executor);
                return result;
            }
        }
        ... // catch
    }
}
```

- `org.apache.dubbo.rpc.protocol.AbstractInvoker`
```java
// sign_c_140
public abstract class AbstractInvoker<T> implements Invoker<T> {

    // sign_m_140  处理调用
    @Override
    public Result invoke(Invocation inv) throws RpcException {
        ... // log

        RpcInvocation invocation = (RpcInvocation) inv;
        ...

        // RPC 调用并返回异步结果
        AsyncRpcResult asyncResult = doInvokeAndReturn(invocation); // ref: sign_m_141

        ... // 如果同步，则等待 RPC 结果

        return asyncResult;
    }

    // sign_m_141  调用并返回结果
    private AsyncRpcResult doInvokeAndReturn(RpcInvocation invocation) {
        AsyncRpcResult asyncResult;
        try {
            asyncResult = (AsyncRpcResult) doInvoke(invocation);    // 调用子类具体实现。ref: sign_m_130
        } 
        ... // catch

        ... // 结果上下文处理

        return asyncResult;
    }
}
```

- `org.apache.dubbo.rpc.protocol.dubbo.LazyConnectExchangeClient`
```java
// sign_c_150
final class LazyConnectExchangeClient implements ExchangeClient {

    // sign_m_150  进行请求
    @Override
    public CompletableFuture<Object> request(
        Object request, int timeout, ExecutorService executor
    ) throws RemotingException {
        ...
        checkClient();  // 初始化客户端并校验，ref: sign_m_151
        return client.request(request, timeout, executor);  // 发送 RPC 请求
    }
    
    // sign_m_151  校验和初始化客户端
    private void checkClient() {
        try {
            initClient();   // ref: sign_m_152
        } 
        ... // catch

        ... // 校验
    }

    // sign_m_152  初始化客户端
    private void initClient() throws RemotingException {
            ... // DCL
            this.client = Exchangers.connect(url, requestHandler);
    }
}
```


---
## 创建客户端
