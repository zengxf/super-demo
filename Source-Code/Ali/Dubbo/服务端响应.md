# Dubbo-服务端响应


---
## 调用栈
```js
// org.apache.dubbo.remoting.transport.netty4.NettyServer #NettyServer
// new RuntimeException("栈跟踪").printStackTrace()

java.lang.RuntimeException: 栈跟踪
    at *.remoting.transport.netty4.NettyServer.<init>(NettyServer.java:84)
    at *.remoting.transport.netty4.NettyTransporter.bind(NettyTransporter.java:35)
    at *.remoting.Transporter$Adaptive.bind(Transporter$Adaptive.java)
    at *.remoting.Transporters.bind(Transporters.java:47)
    at *.remoting.exchange.support.header.HeaderExchanger.bind(HeaderExchanger.java:55)
    at *.remoting.exchange.Exchangers.bind(Exchangers.java:61)
    at *.rpc.protocol.dubbo.DubboProtocol.createServer(DubboProtocol.java:416)
    at *.rpc.protocol.dubbo.DubboProtocol.openServer(DubboProtocol.java:380)
    at *.rpc.protocol.dubbo.DubboProtocol.export(DubboProtocol.java:361)    // ref: sign_m_110
    ...
    at *.rpc.protocol.InvokerCountWrapper.export(InvokerCountWrapper.java:42)
    at *.rpc.Protocol$Adaptive.export(Protocol$Adaptive.java)
    at *.registry.integration.RegistryProtocol.lambda$doLocalExport$3(RegistryProtocol.java:328)
    at *.registry.integration.ExporterFactory.lambda$createExporter$0(ExporterFactory.java:31)
    at java.base/java.util.concurrent.ConcurrentHashMap.computeIfAbsent(ConcurrentHashMap.java:1708)
    at *.registry.integration.ExporterFactory.createExporter(ExporterFactory.java:29)
    at *.registry.integration.RegistryProtocol.doLocalExport(RegistryProtocol.java:328)
    at *.registry.integration.RegistryProtocol.export(RegistryProtocol.java:263)
    ...
    at *.rpc.protocol.InvokerCountWrapper.export(InvokerCountWrapper.java:42)
    at *.rpc.Protocol$Adaptive.export(Protocol$Adaptive.java)
    ...
    at *.config.ServiceConfig.export(ServiceConfig.java:340)
    at *.config.deploy.DefaultModuleDeployer.exportServiceInternal(DefaultModuleDeployer.java:477)
    ...
    at *.config.deploy.DefaultModuleDeployer.start(DefaultModuleDeployer.java:156)
    at *.config.spring.context.DubboDeployApplicationListener.onContextRefreshedEvent(DubboDeployApplicationListener.java:157)
    at *.config.spring.context.DubboDeployApplicationListener.onApplicationEvent(DubboDeployApplicationListener.java:143)
    at *.config.spring.context.DubboDeployApplicationListener.onApplicationEvent(DubboDeployApplicationListener.java:52)
    ...
    at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:586)
    at org.springframework.context.annotation.AnnotationConfigApplicationContext.<init>(AnnotationConfigApplicationContext.java:93)
    at org.apache.dubbo.demo.provider.Application.main(Application.java:29)
```


---
## 单元测试
- `org.apache.dubbo.rpc.protocol.dubbo.DubboInvokerAvailableTest`
```java
class DubboInvokerAvailableTest {

    @Test
    public void testPreferSerialization() throws Exception {
        int port = 31088;
        URL url = URL.valueOf(
                    "dubbo://127.0.0.1:" + port
                        + "/org.apache.dubbo.rpc.protocol.dubbo.IDemoService?" 
                        + "lazy=true&connections=1&timeout=10000&serialization=fastjson&prefer_serialization=fastjson2,hessian2"
                );
        // 快速启动 Netty 并提供服务 (暴露服务)
        // 最终会调用到 DubboProtocol #export(), ref: sign_m_110
        ProtocolUtils.export(new DemoServiceImpl(), IDemoService.class, url);   
        ...
    }
}
```


---
## 启动服务
- `org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol`
```java
// sign_c_110
public class DubboProtocol extends AbstractProtocol {

    // sign_m_110  暴露服务
    @Override
    public <T> Exporter<T> export(Invoker<T> invoker) throws RpcException {
        URL url = invoker.getUrl();

        DubboExporter<T> exporter = new DubboExporter<T>(invoker, ...);
        ... // log

        openServer(url);    // 打开服务，ref: sign_m_111
        ...

        return exporter;
    }

    // sign_m_111  打开服务
    private void openServer(URL url) {
        String key = url.getAddress();
        boolean isServer = url.getParameter(IS_SERVER_KEY, true);

        if (isServer) {
            ProtocolServer server = serverMap.get(key);
            ... // DCL
                        serverMap.put(
                            key, createServer(url)  // 创建服务，ref: sign_m_112
                        );
                        return;
        }
    }
    
    // sign_m_112  创建服务
    private ProtocolServer createServer(URL url) {
        ... // url 添加默认参数设置
        ...

        ExchangeServer server;
        try {
            server = Exchangers.bind(url, requestHandler);  // 开启服务，ref: sign_sm_120
        }
        ... // catch
        ...

        DubboProtocolServer protocolServer = new DubboProtocolServer(server);
        ...
        return protocolServer;
    }
}
```

- `org.apache.dubbo.remoting.exchange.Exchangers`
```java
// sign_c_120
public class Exchangers {

    // sign_sm_120  开启服务
    public static ExchangeServer bind(URL url, ExchangeHandler handler) throws RemotingException {
        ... // 校验

        url = url.addParameterIfAbsent(Constants.CODEC_KEY, "exchange");
        return getExchanger(url)    // 返回 HeaderExchanger 实例
            .bind(url, handler);    // ref: sign_m_130
    }
}
```

- `org.apache.dubbo.remoting.exchange.support.header.HeaderExchanger`
```java
// sign_c_130
public class HeaderExchanger implements Exchanger {

    // sign_m_130
    @Override
    public ExchangeServer bind(URL url, ExchangeHandler handler) throws RemotingException {
        ExchangeServer server;
        boolean isPuServerKey = url.getParameter(IS_PU_SERVER_KEY, false);
        if (isPuServerKey) {
            ...
        } else {
            server = new HeaderExchangeServer(
                    Transporters.bind(  // ref: sign_sm_140
                        url, new DecodeHandler(new HeaderExchangeHandler(handler))
                    )
                );
        }
        return server;
    }
}
```

- `org.apache.dubbo.remoting.Transporters`
  - 适配器参考：[$Adaptive-类-其他生成的类参考 sign_m_270](./$Adaptive-类.md#其他生成的类参考)
```java
// sign_c_140
public class Transporters {
    
    // sign_sm_140
    public static RemotingServer bind(URL url, ChannelHandler... handlers) throws RemotingException {
        ... // 校验
        ChannelHandler handler = ... handlers[0];
        ...

        /*
            返回 Transporter$Adaptive 实例；

            相当于下面的代码：
                ScopeModelUtil.getOrDefault(url.getScopeModel(), Transporter.class).getExtensionLoader(Transporter.class).getExtension("netty")
                    .bind(url, handler)
            
            参考：[$Adaptive-类-其他生成的类参考 sign_m_270]
                extension 底层相当于是 netty4.NettyTransporter 实例，ref: sign_c_150

            创建的服务端对象为 netty4.NettyServer 实例，ref: sign_c_160
         */
        return getTransporter(url)
            .bind(url, handler);    // ref: sign_m_150
    }
}
```

- `org.apache.dubbo.remoting.transport.netty4.NettyTransporter`
```java
// sign_c_150
public class NettyTransporter implements Transporter {

    // sign_m_150  创建 netty4 服务端
    @Override
    public RemotingServer bind(URL url, ChannelHandler handler) throws RemotingException {
        return new NettyServer(url, handler);   // ref: sign_cm_160
    }
}
```

- `org.apache.dubbo.remoting.transport.netty4.NettyServer`
```java
// sign_c_160
public class NettyServer extends AbstractServer {

    // sign_cm_160
    public NettyServer(URL url, ChannelHandler handler) throws RemotingException {
        super(url, ChannelHandlers.wrap(handler, url)); // ref: sign_cm_170
        ...
    }

    // sign_m_160  初始化并启动 netty 服务
    @Override
    protected void doOpen() throws Throwable {
        bootstrap = new ServerBootstrap();
        bossGroup = createBossGroup();
        workerGroup = createWorkerGroup();

        final NettyServerHandler nettyServerHandler = ... new NettyServerHandler(getUrl(), this);   // 初始化关键信道处理器
        ...

        initServerBootstrap(nettyServerHandler);    // 初始化引导，ref: sign_m_161

        // bind
        try {
            ... bootstrap.bind(         // 绑定地址 (启动服务)
                    getBindAddress()    // 监听地址，ref: sign_f_170
                );   
            ...
        } 
        ... // catch
    }

    // sign_m_161 初始化引导
    protected void initServerBootstrap(NettyServerHandler nettyServerHandler) {
        boolean keepalive = getUrl().getParameter(KEEP_ALIVE_KEY, Boolean.FALSE);
        bootstrap
                .group(bossGroup, workerGroup)
                .channel(NettyEventLoopFactory.serverSocketChannelClass())
                .option(ChannelOption.SO_REUSEADDR, Boolean.TRUE)
                .childOption(ChannelOption.TCP_NODELAY, Boolean.TRUE)
                .childOption(ChannelOption.SO_KEEPALIVE, keepalive)
                .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)
                .childHandler(new ChannelInitializer<SocketChannel>() {
                    @Override
                    protected void initChannel(SocketChannel ch) throws Exception {
                        NettyCodecAdapter adapter = new NettyCodecAdapter(getCodec(), getUrl(), NettyServer.this);
                        ...
                        ch.pipeline()
                                .addLast("decoder", adapter.getDecoder())
                                .addLast("encoder", adapter.getEncoder())
                                .addLast("server-idle-handler", new IdleStateHandler(...))
                                .addLast("handler", nettyServerHandler);    // 添加关键信道处理器
                    }
                });
    }
}
```

- `org.apache.dubbo.remoting.transport.AbstractServer`
```java
// sign_c_170
public abstract class AbstractServer extends AbstractEndpoint implements RemotingServer {

    private InetSocketAddress bindAddress;  // sign_f_170  要监听的 IP 地址和端口

    // sign_cm_170
    public AbstractServer(URL url, ChannelHandler handler) throws RemotingException {
        super(url, handler);
        ...

        String bindIp = ... getUrl().getHost();
        int bindPort  = ... getUrl().getPort();
        ...

        bindAddress = new InetSocketAddress(bindIp, bindPort);  // 设置要绑定的 IP 地址和端口，ref: sign_f_170
        ...
        try {
            doOpen();   // 启动服务，ref: sign_m_160
            ... // log
        } 
        ... // catch
        ...
    }
}
```