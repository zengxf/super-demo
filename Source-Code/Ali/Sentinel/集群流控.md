## 测试
- 参考：[热点流控-测试](热点流控.md#测试)

- 新建 `ClusterDemoApplication2`
```java
public class ClusterDemoApplication2 {
    public static void main(String[] args) {
        System.setProperty("csp.sentinel.dashboard.server", "127.0.0.1:8080");
        System.setProperty("project.name", "My-Cluster-8866");
        System.setProperty("server.port", "10012");
        SpringApplication.run(ClusterDemoApplication.class, args);
    }
}
```

- 启动 2 应用后
  - 访问：http://localhost:10010/hello/test1
  - 访问：http://localhost:10012/hello/test1

- 在控制台设置
  - 点击 **集群流控**：http://127.0.0.1:8080/#/dashboard/cluster/server/My-Cluster-8866
  - 点击 **+ 新增 Token Server**：
    - **机器类型** 使用默认：`应用内机器`
    - **选择机器** 选第一个即可
    - **Server 端口** 使用默认：`18730`
    - **最大允许 QPS** 设置为：`2`
    - **请从中选取 client：**
      - 选第一个，再点击 **→**
  - 点击 **保存**
    ```json
    // POST http://127.0.0.1:8080//cluster/assign/single_server/My-Cluster-8866
    {
        "clusterMap": {
            "machineId": "10.32.51.130@8720",
            "ip": "10.32.51.130",
            "port": 18730,
            "clientSet": [
                "10.32.51.130@8721"
            ],
            "belongToApp": true,
            "maxAllowedQps": 2
        },
        "remainingList": []
    }
    ```
  - 点击 **簇点链路**：http://127.0.0.1:8080/#/dashboard/identity/My-Cluster-8866
    - 在 `sayHello` 列，点击 **+ 流控**：
      - **是否集群** 打勾
      - **集群阈值模式** 选 `总体阈值`
      - **集群阈值** 设置为：`2`
      - **其他使用默认值**
    - 点击 **新增**
      ```json
      // POST http://127.0.0.1:8080//v1/flow/rule
      {
        "enable": false,
        "strategy": 0,
        "grade": 1,
        "controlBehavior": 0,
        "resource": "sayHello",
        "limitApp": "default",
        "clusterMode": true,
        "clusterConfig": {
            "thresholdType": "1"
        },
        "app": "My-Cluster-8866",
        "ip": "10.32.51.130",
        "port": "8720",
        "count": 2
      }
      ```

- 再测试
  - 连续刷 3 次：http://localhost:10010/hello/test1
  - 出现：`Oops, [test1] blocked by Sentinel`


## 原理
### 改模式
- Path: `/cluster/assign/single_server/{app}`

#### 控制台
- `com.alibaba.csp.sentinel.dashboard.controller.cluster.ClusterAssignController`
```java
@RestController
@RequestMapping("/cluster/assign")
public class ClusterAssignController {

    // 全路径为: /cluster/assign/single_server/{app}
    @PostMapping("/single_server/{app}")
    public Result<ClusterAppAssignResultVO> apiAssignSingleClusterServersOfApp(
        @PathVariable String app,
        @RequestBody ClusterAppSingleServerAssignRequest assignRequest
    ) {
        ... // 参数校验
        try {
            return Result.ofSuccess(
                clusterAssignService.applyAssignToApp(  // ref: sign_m_100
                    app, Collections.singletonList(assignRequest.getClusterMap()),
                    assignRequest.getRemainingList()
                )
            );
        } ... // catch
    }
}
```

- `com.alibaba.csp.sentinel.dashboard.service.ClusterAssignServiceImpl`
```java
@Service
public class ClusterAssignServiceImpl implements ClusterAssignService {

    // sign_m_100
    @Override
    public ClusterAppAssignResultVO applyAssignToApp(String app, List<ClusterAppAssignMap> clusterMap,
                                                     Set<String> remainingSet) 
    {
        ... // 参数校验

        // 更改集群模式--为服务端 & 推送配置
        clusterMap.stream()
            .filter(Objects::nonNull)
            .filter(ClusterAppAssignMap::getBelongToApp)
            .map(e -> {
                String ip = e.getIp();          // 传过来的值为: 10.32.51.130 (相当于连接到控制台的 Sentinel 使用者的机器 IP)
                int commandPort = parsePort(e); // 从 "machineId": "10.32.51.130@8720" 里取，取的值为: 8720
                CompletableFuture<Void> f = modifyMode(ip, commandPort, ClusterStateManager.CLUSTER_SERVER) // 改集群模式, ref: sign_m_101
                    .thenCompose(v -> applyServerConfigChange(app, ip, commandPort, e));                    // 推送配置,   ref: sign_m_102 
                return Tuple2.of(e.getMachineId(), f);
            })
            .forEach(t -> handleFutureSync(t, failedServerSet));    // 失败或超时 (10s) 则记录到集合里

        // 更改集群模式--为客户端 & 推送配置
        clusterMap.parallelStream()
            .filter(Objects::nonNull)
            .forEach(e -> applyAllClientConfigChange(app, e, failedClientSet)); // 改集群模式为客户端并推送配置, ref: sign_m_110

        // 解绑剩余 (未分配的) 机器
        applyAllRemainingMachineSet(app, remainingSet, failedClientSet);

        return new ClusterAppAssignResultVO() ... // 组装失败的 Client/Server 集合并返回
    }

    // sign_m_101 改集群模式
    private CompletableFuture<Void> modifyMode(String ip, int port, int mode) {
        return sentinelApiClient.modifyClusterMode(ip, port, mode); // 命令为: setClusterMode, 处理者 ref: sign_c_110
    }
    
    // sign_m_102 推送配置给服务端
    private CompletableFuture<Void> applyServerConfigChange(String app, String ip, int commandPort,
                                                            ClusterAppAssignMap assignMap) 
    {
        ServerTransportConfig transportConfig = new ServerTransportConfig()
            .setPort(assignMap.getPort())   // 传过来的值为: 18730
            .setIdleSeconds(600);
        /**
         * 推送服务端配置 (服务端口) 
         * 命令为: cluster/server/modifyTransportConfig
         */
        return sentinelApiClient.modifyClusterServerTransportConfig(app, ip, commandPort, transportConfig)
            .thenCompose(v -> applyServerFlowConfigChange(app, ip, commandPort, assignMap))     // 推送集群整体流控 QPS, ref: sign_m_103
            .thenCompose(v -> applyServerNamespaceSetConfig(app, ip, commandPort, assignMap));  // 传过来的 namespaceSet 为空，不会处理，略...
    }

    // sign_m_103 推送集群整体流控 QPS
    private CompletableFuture<Void> applyServerFlowConfigChange(String app, String ip, int commandPort,
                                                                ClusterAppAssignMap assignMap) 
    {
        Double maxAllowedQps = assignMap.getMaxAllowedQps();
        ... // maxAllowedQps 校验。注: QPS 大于 20w 则不推送
        /**
         * 推送集群流控配置
         * 命令为: cluster/server/modifyFlowConfig
         */
        return sentinelApiClient.modifyClusterServerFlowConfig(app, ip, commandPort,
            new ServerFlowConfig().setMaxAllowedQps(maxAllowedQps));
    }

    // sign_m_110 改集群模式为客户端并推送配置
    private void applyAllClientConfigChange(String app, ClusterAppAssignMap assignMap,
                                            Set<String> failedSet) 
    {
        Set<String> clientSet = assignMap.getClientSet();
        ... // 空校验
        final String serverIp = assignMap.getIp();  // 集群服务端 IP:  10.32.51.130
        final int serverPort = assignMap.getPort(); // 集群服务端端口: 18730
        clientSet.stream()
            .map(MachineUtils::parseCommandIpAndPort)
            .filter(Optional::isPresent)
            .map(Optional::get)
            .map(ipPort -> {    // 将客户端机器 ID 用 @ 符截取成 [ip, port] 元组
                CompletableFuture<Void> f = sentinelApiClient
                    /**
                     * 改集群模式为客户端，命令为: setClusterMode
                     * 处理者 ref: sign_c_110
                     */
                    .modifyClusterMode(ipPort.r1, ipPort.r2, ClusterStateManager.CLUSTER_CLIENT)
                    /**
                     * 推送客户端配置 (服务端的 IP 和端口) 
                     * 命令为: cluster/client/modifyConfig
                     */
                    .thenCompose(v -> sentinelApiClient.modifyClusterClientConfig(app, ipPort.r1, ipPort.r2,
                        new ClusterClientConfig().setRequestTimeout(20)
                            .setServerHost(serverIp)
                            .setServerPort(serverPort)
                    ));
                return Tuple2.of(ipPort.r1 + '@' + ipPort.r2, f);
            })
            .forEach(t -> handleFutureSync(t, failedSet));  // 失败或超时 (10s) 则记录到集合里
    }

}
```

#### 应用机器
- `com.alibaba.csp.sentinel.command.handler.cluster.ModifyClusterModeCommandHandler`
```java
// sign_c_110 改集群模式命令处理者
@CommandMapping(name = "setClusterMode", desc = "set cluster mode...")
public class ModifyClusterModeCommandHandler implements CommandHandler<String> {

    @Override
    public CommandResponse<String> handle(CommandRequest request) {
        try {
            int mode = Integer.valueOf(request.getParam("mode"));
            ... // 对模式对应的 SPI 的校验

            ClusterStateManager.applyState(mode);   // 改模式, ref: sign_m_200
            return CommandResponse.ofSuccess("success");
        } ... // catch
    }
}
```

- `com.alibaba.csp.sentinel.cluster.ClusterStateManager`
  - `DynamicSentinelProperty` 参考：[入口控制-设置规则 sign_c_100](入口控制.md#设置规则)
```java
public final class ClusterStateManager {

    private static volatile SentinelProperty<Integer> stateProperty = new DynamicSentinelProperty<Integer>();
    private static final PropertyListener<Integer> PROPERTY_LISTENER = new ClusterStatePropertyListener();

    static {
        InitExecutor.doInit();
        stateProperty.addListener(PROPERTY_LISTENER);
    }
    
    // sign_m_200 改模式
    public static void applyState(Integer state) {
        stateProperty.updateValue(state);   // 最终触发内部处理, ref: sign_m_210
    }
    
    private static class ClusterStatePropertyListener implements PropertyListener<Integer> {
        ... // configLoad 实现

        @Override
        public synchronized void configUpdate(Integer value) {
            applyStateInternal(value);
        }
    }
    
    // sign_m_210 状态更改处理
    private static boolean applyStateInternal(Integer state) {
        ... // state 校验
        try {
            switch (state) {
                case CLUSTER_CLIENT:
                    return setToClient();   // 设置为客户端模式, ref: sign_m_211
                case CLUSTER_SERVER:
                    return setToServer();   // 设置为服务端模式, ref: sign_m_215
                case CLUSTER_NOT_STARTED:
                    setStop();
                    return true;
                ... // default 处理
            }
        } ... // catch
    }

    // sign_m_211 设置为客户端模式
    public static boolean setToClient() {
        if (mode == CLUSTER_CLIENT) {
            return true;
        }
        mode = CLUSTER_CLIENT;
        sleepIfNeeded();        // 转换完之后，至少要等 5s 才能换模式
        lastModified = TimeUtil.currentTimeMillis();
        return startClient();   // ref: sign_m_212
    }

    // sign_m_212 启动客户端并关闭服务端
    private static boolean startClient() {
        try {
            EmbeddedClusterTokenServer server = EmbeddedClusterTokenServerProvider.getServer();
            if (server != null) {
                server.stop();
            }
            ClusterTokenClient tokenClient = TokenClientProvider.getClient();
            if (tokenClient != null) {  // 默认实现为 DefaultClusterTokenClient, ref: sign_c_230
                tokenClient.start();    // ref: sign_m_230
                RecordLog.info("[ClusterStateManager] Changing cluster mode to client");
                return true;
            } ... // else
        } ... // catch
    }

    // sign_m_215 设置为服务端模式
    public static boolean setToServer() {
        ... // 同样要等 5s 才能换模式
        return startServer();   // ref: sign_m_216
    }

    // sign_m_216 启动服务端并关闭客户端
    private static boolean startServer() {
        try {
            ClusterTokenClient tokenClient = TokenClientProvider.getClient();
            if (tokenClient != null) {
                tokenClient.stop();
            }
            EmbeddedClusterTokenServer server = EmbeddedClusterTokenServerProvider.getServer();
            if (server != null) {       // 默认实现为 DefaultEmbeddedTokenServer, ref: sign_c_220
                server.start();         // ref: sign_m_218
                RecordLog.info("[ClusterStateManager] Changing cluster mode to server");
                return true;
            } ... // else
        } ... // catch
    }
}
```

##### 启用服务端
- `com.alibaba.csp.sentinel.cluster.server.DefaultEmbeddedTokenServer`
```java
/** sign_c_220 默认内嵌 Token 服务器 */
public class DefaultEmbeddedTokenServer implements EmbeddedClusterTokenServer {

    // 相当于对此进行一层封装
    private final ClusterTokenServer server = new SentinelDefaultTokenServer(true); // ref: sign_cm_221

    // sign_m_218
    @Override
    public void start() throws Exception {
        server.start(); // ref: sign_m_220
    }
}
```

- `com.alibaba.csp.sentinel.cluster.server.SentinelDefaultTokenServer`
```java
public class SentinelDefaultTokenServer implements ClusterTokenServer {

    // sign_cm_221
    public SentinelDefaultTokenServer(boolean embedded) {
        this.embedded = embedded;
        ClusterServerConfigManager.addTransportConfigChangeObserver(new ServerTransportConfigObserver() {
            @Override
            public void onTransportConfigChange(ServerTransportConfig config) {
                changeServerConfig(config); // ref: sign_m_221
            }
        });
        initNewServer();    // 只是创建，并未启动...
    }

    // sign_m_220
    @Override
    public void start() throws Exception {
        if (shouldStart.compareAndSet(false, true)) {
            startServerIfScheduled();   // ref: sign_m_222
        }
    }

    // sign_m_221
    private synchronized void changeServerConfig(ServerTransportConfig config) {
        ...
        int newPort = config.getPort();
        ... // 新端口与旧端口相同，则返回。(相当于界面用非默认端口 `18730`，则会启动 2 次 Netty 服务)
        try {
            if (server != null) {
                stopServer();
            }
            this.server = new NettyTransportServer(newPort);
            this.port = newPort;
            startServerIfScheduled();   
        } ... // catch
    }

    // sign_m_222
    private void startServerIfScheduled() throws Exception {
        if (shouldStart.get()) {
            if (server != null) {
                server.start();         // 启动 Netty 服务
                ClusterStateManager.markToServer();
                if (embedded) {
                    handleEmbeddedStart();
                }
            }
        }
    }
}
```

##### 启用客户端
- `com.alibaba.csp.sentinel.cluster.client.DefaultClusterTokenClient`
```java
/** sign_c_230 默认客户端 */
public class DefaultClusterTokenClient implements ClusterTokenClient {

    // SPI 加载时会调用
    public DefaultClusterTokenClient() {
        ClusterClientConfigManager.addServerChangeObserver(new ServerChangeObserver() {
            @Override
            public void onRemoteServerChange(ClusterClientAssignConfig assignConfig) {
                changeServer(assignConfig); // ref: sign_m_231
            }
        });
        initNewConnection();    // host 为空，不会创建连接...
    }
    
    // sign_m_230
    @Override
    public void start() throws Exception {
        if (shouldStart.compareAndSet(false, true)) {
            startClientIfScheduled();   // ref: sign_m_232
        }
    }
    
    // sign_m_231
    private void changeServer(ClusterClientAssignConfig config) {
        ... // 服务端的 IP 和端口没改，则返回不处理

        try {
            if (transportClient != null) {
                transportClient.stop();
            }
            this.transportClient = new NettyTransportClient(config.getServerHost(), config.getServerPort());
            ... // 记录配置
            startClientIfScheduled();   // ref: sign_m_232
        } ... // catch
    }

    // sign_m_232
    private void startClientIfScheduled() throws Exception {
        if (shouldStart.get()) {
            if (transportClient != null) {
                transportClient.start();    // 启动 Netty 连接
            } ... // else
        }
    }
}
```


### 流控原理
- 参考：
  - [链路控制-ClusterBuilderSlot](链路控制.md#ClusterBuilderSlot)
  - [链路控制-FlowSlot](链路控制.md#FlowSlot)