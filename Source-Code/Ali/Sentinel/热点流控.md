## Demo
- 模块：`sentinel-demo-cluster-embedded`

- `com.alibaba.csp.sentinel.demo.cluster.app.ClusterDemoApplication`
  - 更改如下：
```java
@SpringBootApplication
public class ClusterDemoApplication {
    public static void main(String[] args) {
        System.setProperty("csp.sentinel.dashboard.server", "127.0.0.1:8080");
        System.setProperty("project.name", "My-Cluster-8866");
        System.setProperty("server.port", "10010");
        SpringApplication.run(ClusterDemoApplication.class, args);
    }
}
```

- 启动后
  - 访问：http://localhost:10010/hello/test1

- 在控制台设置规则
  - 点击 **簇点链路**：http://127.0.0.1:8080/#/dashboard/identity/My-Cluster-8866
    - 点击 **+ 热点**：
      - **单机阈值** 设置为：`20`
    - 点击 **新增**
    ```json
    // POST http://127.0.0.1:8080//paramFlow/rule
    {
        "app": "My-Cluster-8866",
        "ip": "10.32.51.130",
        "port": "8720",
        "rule": {
            "resource": "com.alibaba.csp.sentinel.demo.cluster.app.service.DemoService:sayHello(java.lang.String)",
            "grade": 1,
            "paramFlowItemList": [],
            "count": 20,
            "limitApp": "default",
            "controlBehavior": 0,
            "durationInSec": 1,
            "burstCount": 0,
            "maxQueueingTimeMs": 0,
            "clusterMode": false,
            "clusterConfig": {
            "thresholdType": 0,
            "fallbackToLocalWhenFail": true
            },
            "paramIdx": 0
        }
    }
    ```
  - 新增完会跳转到 **热点规则**：http://127.0.0.1:8080/#/dashboard/paramFlow/My-Cluster-8866
    - 点击 **编辑**
    - 再点 **高级选项**
      - **参数类型** 设置为：`java.lang.String`
      - **参数值** 设置为：`test1`
      - **限流阈值** 设置为：`2`
      - 点击 **+ 添加**
    - 点击 **保存**
    ```json
    // PUT http://127.0.0.1:8080//paramFlow/rule/2
    {
        "id": 2,
        "app": "My-Cluster-8866",
        "ip": "10.32.51.130",
        "port": 8720,
        "rule": {
            "id": null,
            "resource": "com.alibaba.csp.sentinel.demo.cluster.app.service.DemoService:sayHello(java.lang.String)",
            "limitApp": "default",
            "grade": 1,
            "paramIdx": 0,
            "count": 20,
            "controlBehavior": 0,
            "maxQueueingTimeMs": 0,
            "burstCount": 0,
            "durationInSec": 1,
            "paramFlowItemList": [
            {
                "object": "test1",
                "classType": "java.lang.String",
                "count": 2
            }
            ],
            "clusterMode": false,
            "clusterConfig": {
            "flowId": null,
            "thresholdType": 0,
            "fallbackToLocalWhenFail": true,
            "sampleCount": 10,
            "windowIntervalMs": 1000
            }
        },
        "gmtCreate": null,
        "gmtModified": null
    }
    ```

- 再测试
  - 连续刷 3 次：http://localhost:10010/hello/test1
  - 出现：`Oops, blocked by Sentinel`


## 原理
- 模块：`sentinel-parameter-flow-control`
  - 其 SPI 配置文件 `../META-INF/services/com.alibaba.csp.sentinel.slotchain.ProcessorSlot`
    - 内容为：`com.alibaba.csp.sentinel.slots.block.flow.param.ParamFlowSlot`

- `com.alibaba.csp.sentinel.slots.block.flow.param.ParamFlowSlot`
  - 参考：[入口控制-处理链](入口控制.md#处理链)
```java
@Spi(order = -3000)
public class ParamFlowSlot extends AbstractLinkedProcessorSlot<DefaultNode> {
    @Override
    public void entry(Context context, ResourceWrapper resourceWrapper, DefaultNode node, int count,
                      boolean prioritized, Object... args) throws Throwable 
    {
        ... // 如果资源没设置热点规则，则传给下个节点并返回

        checkFlow(resourceWrapper, count, args);                                // 检测规则，ref: sign_m_100
        fireEntry(context, resourceWrapper, node, count, prioritized, args);    // 传给下游
    }

    // sign_m_100 检测规则
    void checkFlow(ResourceWrapper resourceWrapper, int count, Object... args) throws BlockException {
        ... // args 为 null 校验 & 资源是否设置有规则校验

        List<ParamFlowRule> rules = ParamFlowRuleManager.getRulesOfResource(resourceWrapper.getName());

        for (ParamFlowRule rule : rules) {
            applyRealParamIdx(rule, args.length);   // 重新设置下索引，ref: sign_m_110

            // 初始化指标
            ParameterMetricStorage.initParamMetricsFor(resourceWrapper, rule);

            if (!ParamFlowChecker.passCheck(resourceWrapper, rule, count, args)) {  // 规则检验 (不通过则报错)，ref: sign_m_210
                String triggeredParam = "";
                ... // 从参数数组里获取校验索引的值，即: = args[idx]
                throw new ParamFlowException(resourceWrapper.getName(), triggeredParam, rule);
            }
        }
    }

    /**
     * sign_m_110 设置正确的索引：
     * 
     *   1. len: 5, idx: -3 (倒数第 3 个)
     *      idx = 5 + (-3) = 2
     * 
     *   2. len: 5, idx: -6 (倒数第 6 个，无效索引)
     *      idx = -(-6) = 6
     */
    void applyRealParamIdx(ParamFlowRule rule, int length) {
        int paramIdx = rule.getParamIdx();
        if (paramIdx < 0) {
            if (-paramIdx <= length) {
                rule.setParamIdx(length + paramIdx);
            } else {
                // 非法索引，给它一个非法的正值，后面的规则检查就会通过。ref: sign_m_210
                rule.setParamIdx(-paramIdx);
            }
        }
    }
}
```

- `com.alibaba.csp.sentinel.slots.block.flow.param.ParamFlowChecker`
```java
public final class ParamFlowChecker {

    // sign_m_210 规则检验
    public static boolean passCheck(ResourceWrapper resourceWrapper, ParamFlowRule rule, int count,
                             Object... args) 
    {
        ... // args 为 null，返回 true 表示校验通过

        int paramIdx = rule.getParamIdx();

        ... // args 长度不满足，返回 true 表示校验通过，对应上面: sign_m_110

        Object value = args[paramIdx];

        ... // value 为 ParamFlowArgument 时，使用其 paramFlowKey
        ... // value 为 null，返回 true 表示校验通过

        ... // 集群模式校验

        return passLocalCheck(resourceWrapper, rule, count, value); // 本地校验，ref: sign_m_212
    }

    // sign_m_212 本地校验
    private static boolean passLocalCheck(ResourceWrapper resourceWrapper, ParamFlowRule rule, int count,
                                          Object value) 
    {
        try {
            if (Collection.class.isAssignableFrom(value.getClass())) {
                ... // 是集合，则对集合里的每个元素进行校验
            } else if (value.getClass().isArray()) {
                ... // 是数组，则对数组的每个元素进行校验
            } else {
                return passSingleValueCheck(resourceWrapper, rule, count, value);   // 单个值校验，ref: sign_m_213
            }
        } ... // catch 

        return true;    // 校验过程中出现异常，则当作"通过"
    }

    // sign_m_213 单个值校验
    static boolean passSingleValueCheck(ResourceWrapper resourceWrapper, ParamFlowRule rule, int acquireCount,
                                        Object value) 
    {
        if (rule.getGrade() == RuleConstant.FLOW_GRADE_QPS) {
            if (rule.getControlBehavior() == RuleConstant.CONTROL_BEHAVIOR_RATE_LIMITER) {
                return passThrottleLocalCheck(resourceWrapper, rule, acquireCount, value);
            } else {
                // 默认是 CONTROL_BEHAVIOR_DEFAULT，使用默认校验，ref: sign_m_214
                return passDefaultLocalCheck(resourceWrapper, rule, acquireCount, value);
            }
        } else if (rule.getGrade() == RuleConstant.FLOW_GRADE_THREAD) {
            ... // 通过线程数进行流控
        }

        return true;
    }

    // sign_m_214 默认校验
    static boolean passDefaultLocalCheck(ResourceWrapper resourceWrapper, ParamFlowRule rule, int acquireCount,
                                         Object value) 
    {
        ParameterMetric metric = getParameterMetric(resourceWrapper);
        CacheMap<Object, AtomicLong> tokenCounters = metric == null ? null : metric.getRuleTokenCounter(rule);
        CacheMap<Object, AtomicLong> timeCounters = metric == null ? null : metric.getRuleTimeCounter(rule);

        if (tokenCounters == null || timeCounters == null) {
            return true;
        }

        // Calculate max token count (threshold)
        Set<Object> exclusionItems = rule.getParsedHotItems().keySet();
        long tokenCount = (long)rule.getCount();
        if (exclusionItems.contains(value)) {
            tokenCount = rule.getParsedHotItems().get(value);
        }

        if (tokenCount == 0) {
            return false;
        }

        long maxCount = tokenCount + rule.getBurstCount();
        if (acquireCount > maxCount) {
            return false;
        }

        while (true) {
            long currentTime = TimeUtil.currentTimeMillis();

            AtomicLong lastAddTokenTime = timeCounters.putIfAbsent(value, new AtomicLong(currentTime));
            if (lastAddTokenTime == null) {
                // Token never added, just replenish the tokens and consume {@code acquireCount} immediately.
                tokenCounters.putIfAbsent(value, new AtomicLong(maxCount - acquireCount));
                return true;
            }

            // Calculate the time duration since last token was added.
            long passTime = currentTime - lastAddTokenTime.get();
            // A simplified token bucket algorithm that will replenish the tokens only when statistic window has passed.
            if (passTime > rule.getDurationInSec() * 1000) {
                AtomicLong oldQps = tokenCounters.putIfAbsent(value, new AtomicLong(maxCount - acquireCount));
                if (oldQps == null) {
                    // Might not be accurate here.
                    lastAddTokenTime.set(currentTime);
                    return true;
                } else {
                    long restQps = oldQps.get();
                    long toAddCount = (passTime * tokenCount) / (rule.getDurationInSec() * 1000);
                    long newQps = toAddCount + restQps > maxCount ? (maxCount - acquireCount)
                        : (restQps + toAddCount - acquireCount);

                    if (newQps < 0) {
                        return false;
                    }
                    if (oldQps.compareAndSet(restQps, newQps)) {
                        lastAddTokenTime.set(currentTime);
                        return true;
                    }
                    Thread.yield();
                }
            } else {
                AtomicLong oldQps = tokenCounters.get(value);
                if (oldQps != null) {
                    long oldQpsValue = oldQps.get();
                    if (oldQpsValue - acquireCount >= 0) {
                        if (oldQps.compareAndSet(oldQpsValue, oldQpsValue - acquireCount)) {
                            return true;
                        }
                    } else {
                        return false;
                    }
                }
                Thread.yield();
            }
        }
    }

}
```